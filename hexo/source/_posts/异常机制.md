title: 异常机制
tags:
  - Java基础
categories:
  - Java
date: 2017-12-07 12:56:00
---
### 概述

**异常：**程序在**运行时**出现不正常情况。

Java将异常分为checked异常、unchecked异常

### unchecked异常(非受查异常)

**定义：**所有派生于Error类或RuntimeException类的异常都称为unchecked异常

如果在函数内抛出异常，函数上不用声明，函数一样通过。

如果在函数上声明了该异常，调用者可以不用进行处理，编译一样通过。

之所以不用函数声明，是因为不需要让调用者处理。当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，由程序员修改。


### Checked异常（受查异常）

**定义：**不是RuntimeException类及其子类的实例都称为Checked异常。

可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException
如果不处理，编译器，就不让你通过。

也就是说Java认为Checked异常是可以修复的异常，所以Java程序必须显式处理Checked异常，如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。

**运行时异常与非运行时异常的区别：**
运行时异常是不可查异常，不需要进行显式的捕捉
非运行时异常是可查异常，必须进行显示的捕捉，或者抛出<!--more-->

## 异常处理机制

当程序运行出现意外情形时，系统会自动生成一个Exception对象来通知程序，从而实现将”业务功能实现代码“和“错误处理代码”分离，提供更好的可读性。

总结：一个方法必须声明所有可能抛出的(check)受查异常，而（uncheck）非受查异常要么不可控制（Error）要么就应该避免发生（RuntimeException）。

下面为异常的处理

### 方式一：try...catch捕获异常

```java
try
{
  //有可能产生异常的业务实现代码
}
catch(Exception e)//异常对象
{
  System.out.println(e.toString());//异常名称：异常信息
  e.printStackTrace();//异常名称：异常信息,异常出现的位置
}
finally
{
  //一定会执行的语句
}
```

### 方式二：使用throws声明抛出异常

**使用场景：**当前方法不知道如何处理这种类型或者是可能抛出的异常，该异常应该由上一级调用者处理；如果main方法也不知道如何处理这种类型的异常，就使用throws声明抛出异常。该异常交给JVM处理，JVM对异常的处理方法是，打印异常的跟踪栈信息，并终止程序运行。

```java
package exception;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class TestException {

	public static void main(String[] args) {
		method1();
	}

	private static void method1() {
		try {
          //因为method2()方法声明抛出FileNotFoundException异常，所以调用该方法的代码要么放在try块中显示捕获该异常，要么放在另一个带throws声明抛出的方法中。
			method2();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

  //该方法希望它的调用者来处理异常,也就是说，调用该方法时要么放在try块中显示捕获该异常，要么放在另一个带throws声明抛出的方法中。
	private static void method2() throws FileNotFoundException {

		File f = new File("d:/LOL.exe");
		System.out.println("试图打开 d:/LOL.exe");
		new FileInputStream(f);
		System.out.println("成功打开");

	}
}
```

**注意：**throws声明抛出异常时有限制：子类方法声明抛出的异常类型应该是父类方法声明抛出类型的子类或相同，子类方法声明抛出异常不允许比父类方法声明抛出的异常多。如下

```java
public class OverrideThrows
{
	public void test() throws IOException
	{
		FileInputStream fis = new FileInputStream("a.txt");
	}
}
class Sub extends OverrideThrows
{
	// 子类方法声明抛出了比父类方法更大的异常
	// 所以下面方法出错
	public void test() throws Exception
	{
	}
}
```

**抛出异常：**代码出现异常时，系统自动生成一个异常对象，该异常对象被提交给Java环境。

**捕获异常：**Java运行时环境收到异常对象，会寻找能处理该异常对象的catch块，如果找到合适的catch块，则把该异常对象交给catch块处理。

### 程序自行抛出异常（throw）

throw语句抛出的不是异常类，而是一个异常实例；语法如下：

throw ExceptionInstance;

```java
try{
  if(业务实现代码出现异常的条件){
	throw new Exception("出现异常")；
}
}catch(Exception e){
  System.out.println("异常");
}
```

## throws与throw区别

throws使用在函数上；throw使用在函数内。

throws后面跟的异常类，可以跟多个，用逗号隔开；throw后面跟的是异常对象。

## 访问异常信息

```
getMessage():返回该异常的详细描述字符串
printStackTrace():将该异常的跟踪栈信息输出到标准错误输出
printStackTrace(PrintStream s):将该异常的跟踪栈信息输出到指定输出流。
getStackTrace():返回该异常的跟踪栈信息。
```

## 自定义异常

**应用场景:**项目中会出现特有问题，而这些问题并未被java所所描述并封装对象。所以对于这些特有的问题可以按照java的对问题的封装思想，将特有的问题，进行自定义的异常封装。自定义异常必须继承Exception类。

1. 创建自定义异常

   一个英雄攻击另一个英雄的时候，如果发现另一个英雄已经挂了，就会抛出EnemyHeroIsDeadException
   创建一个类EnemyHeroIsDeadException，并继承Exception
   提供两个构造方法
   1. 无参的构造方法

   2. 带参的构造方法，并调用父类的对应的构造方法

      ```java
      class EnemyHeroIsDeadException extends Exception{
           
          public EnemyHeroIsDeadException(){
               
          }
          public EnemyHeroIsDeadException(String msg){
              super(msg);
          }
      }
      ```

      ​



2. 抛出自定义异常

   在Hero的attack方法中，当发现敌方英雄的血量为0的时候，抛出该异常
   1. 创建一个EnemyHeroIsDeadException实例
   2. 通过throw 抛出该异常
   3. 当前方法通过 throws 抛出该异常


   ```java
   public class Hero {
       public String name; 
       protected float hp;
    
       public void attackHero(Hero h) throws EnemyHeroIsDeadException{
           if(h.hp == 0){
               throw new EnemyHeroIsDeadException(h.name + " 已经挂了,不许要施放技能" );
           }
       }
    
       public String toString(){
           return name;
       }
        
       class EnemyHeroIsDeadException extends Exception{
            
           public EnemyHeroIsDeadException(){
                
           }
           public EnemyHeroIsDeadException(String msg){
               super(msg);
           }
       }
         
       public static void main(String[] args) {
            
           Hero garen =  new Hero();
           garen.name = "盖伦";
           garen.hp = 616;
    
           Hero teemo =  new Hero();
           teemo.name = "提莫";
           teemo.hp = 0;
            
           try {
               garen.attackHero(teemo);
                
           } catch (EnemyHeroIsDeadException e) {
               // TODO Auto-generated catch block
               System.out.println("异常的具体原因:"+e.getMessage());
               e.printStackTrace();
           }
            
       }
   }
   ```

   ​

### finally

**作用：**回收try块中打开了一些物理资源（例如数据库连接、网络连接和磁盘文件等），这些资源都必须显示回收。

不管try块中的代码是否出现异常，也不管哪一个catch块被执行，**甚至在try块或catch块中执行了return语句，finally总会被执行。**

### Throwable

 ![Throwable](/images/img-Throwable.png)

Throwable是类，Exception和Error都继承了该类，所以在捕捉的时候，也可以使用Throwable进行捕捉。
如图： 异常分Error和Exception
Exception里又分运行时异常和可查异常。

```java
import java.io.File;
import java.io.FileInputStream;
 
public class TestException {
 
    public static void main(String[] args) {
 
        File f = new File("d:/LOL.exe");
 
        try {
            new FileInputStream(f);
            //使用Throwable进行异常捕捉
        } catch (Throwable t) {
            // TODO Auto-generated catch block
            t.printStackTrace();
        }
    }
}
```