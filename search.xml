<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Security（四）Spring Social]]></title>
    <url>%2Fposts%2F1444918557%2F</url>
    <content type="text"><![CDATA[Spring Security（四）Spring Social1. OAuth流程 资源所有者访问第三方应用 第三方应用请求授权 资源所有者同意授权 第三方应用去认证服务器申请令牌 认证服务器验证用户是否授权给第三方，发放令牌 第三方通过令牌，请求资源服务器 资源服务器通过令牌去认证服务器判断是否有用，开放资源 2. OAuth的授权模式 授权码模式 密码模式 客户端模式 简化模式 3. 授权码模式用户同意授权是在认证服务器进行的。 4.Spring Social基本原理第三方登录 通过授权码模式获取用户基本信息，第三方通过用户信息构建Authentication并放入SecurityContext中,从而实现登录。 1-5是标准流程 6每个服务商提供的个人信息不一样 服务提供商 ServiceProvider(AbstractOAuth2ServiceProvider) 实现了服务提供商1-5的流程Oauth2Operation(OAutheTemplate) 封装6 Api(AbstractOauthApiBinding) 与7相关的：Connection(Oauth2Connection)由ConnectionFactory(OAuth2ConnectionFactory)创建的，ConnectionFactory(OAuth2ConnectionFactory)里面包含了ServiceProvider实例的，使用这个ServiceProvider走1-6流程，ApiAdapter将每个服务商不同的数据结构转化为Connection(Oauth2Connection)。 服务商的用户信息如何与我们的业务的用户信息关联？ 通过数据库DB UserConnection的表服务商的用户信息与业务的用户信息的对应关系，通过UsersConnectionRepository(JdbcUsersConnectionRepository)操作这个表。 4.1. Spring Social实现QQ登录]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security（二）记住我]]></title>
    <url>%2Fposts%2F1444918557%2F</url>
    <content type="text"><![CDATA[Spring Security（二）记住我1.记住我基本原理 2. 实现2.1 修改登录页增加记住我的checkbox，name值固定为remember-me 1234&lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;记住我： &lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot;&gt;&lt;/td&gt;&lt;/tr&gt; 2.2. 增加remember的spring security的配置创建PersistentTokenRepository 1234567@Bean public PersistentTokenRepository persistentTokenRepository()&#123; JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl(); tokenRepository.setDataSource(dataSource);// tokenRepository.setCreateTableOnStartup(true); 自动建表，建好后注释掉 return tokenRepository; &#125; 12345678910111213141516171819202122232425262728@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.apply(validateCodeSecurityConfig) .and() .formLogin() //表单验证 .loginPage(&quot;/authentication/require&quot;) .loginProcessingUrl(&quot;/authentication/form&quot;) .successHandler(number47AuthenticationSuccessHandler) .failureHandler(number47AuthenticationFailureHandler) .and() //记住我 .rememberMe() .tokenRepository(persistentTokenRepository()) //过期时间 .tokenValiditySeconds(securityProperties.getBrowser().getRememberMeSeconds()) .userDetailsService(userDetailsService) .and() .authorizeRequests() //对请求进行授权 //不需要认证的请求 .antMatchers(&quot;/authentication/require&quot;, &quot;/code/image&quot;, securityProperties.getBrowser().getLoginPage()) .permitAll() .anyRequest() //任何请求 .authenticated()//身份认证 .and() .csrf().disable(); //跨站伪造请求关闭&#125; 3. 解析Spring Security登录成功之后到AbstractAuthenticationProcessingFilter的successfulAuthentication的方法中 AbstractAuthenticationProcessingFilter 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Default behaviour for successful authentication. * &lt;ol&gt; * &lt;li&gt;Sets the successful &lt;tt&gt;Authentication&lt;/tt&gt; object on the * &#123;@link SecurityContextHolder&#125;&lt;/li&gt; * &lt;li&gt;Informs the configured &lt;tt&gt;RememberMeServices&lt;/tt&gt; of the successful login&lt;/li&gt; * &lt;li&gt;Fires an &#123;@link InteractiveAuthenticationSuccessEvent&#125; via the configured * &lt;tt&gt;ApplicationEventPublisher&lt;/tt&gt;&lt;/li&gt; * &lt;li&gt;Delegates additional behaviour to the &#123;@link AuthenticationSuccessHandler&#125;.&lt;/li&gt; * &lt;/ol&gt; * * Subclasses can override this method to continue the &#123;@link FilterChain&#125; after * successful authentication. * @param request * @param response * @param chain * @param authResult the object returned from the &lt;tt&gt;attemptAuthentication&lt;/tt&gt; * method. * @throws IOException * @throws ServletException */protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Authentication success. Updating SecurityContextHolder to contain: &quot; + authResult); &#125; SecurityContextHolder.getContext().setAuthentication(authResult); //记住我 rememberMeServices.loginSuccess(request, response, authResult); // Fire event if (this.eventPublisher != null) &#123; eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent( authResult, this.getClass())); &#125; successHandler.onAuthenticationSuccess(request, response, authResult);&#125; PersistentTokenBasedRememberMeServices 1234567891011121314151617181920212223/** * Creates a new persistent login token with a new series number, stores the data in * the persistent token repository and adds the corresponding cookie to the response. * */protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) &#123; String username = successfulAuthentication.getName(); logger.debug(&quot;Creating new persistent login for user &quot; + username); PersistentRememberMeToken persistentToken = new PersistentRememberMeToken( username, generateSeriesData(), generateTokenData(), new Date()); try &#123; //创建token，保存到数据库 tokenRepository.createNewToken(persistentToken); //token写到浏览器 addCookie(persistentToken, request, response); &#125; catch (Exception e) &#123; logger.error(&quot;Failed to save persistent token &quot;, e); &#125;&#125; 重启应用，直接访问服务的时候，进入到RememberMeAuthenticationFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; if (SecurityContextHolder.getContext().getAuthentication() == null) &#123; //调用AbstractRememberMeServices的autoLogin Authentication rememberMeAuth = rememberMeServices.autoLogin(request, response); if (rememberMeAuth != null) &#123; // Attempt authenticaton via AuthenticationManager try &#123; rememberMeAuth = authenticationManager.authenticate(rememberMeAuth); // Store to SecurityContextHolder SecurityContextHolder.getContext().setAuthentication(rememberMeAuth); onSuccessfulAuthentication(request, response, rememberMeAuth); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;SecurityContextHolder populated with remember-me token: &apos;&quot; + SecurityContextHolder.getContext().getAuthentication() + &quot;&apos;&quot;); &#125; // Fire event if (this.eventPublisher != null) &#123; eventPublisher .publishEvent(new InteractiveAuthenticationSuccessEvent( SecurityContextHolder.getContext() .getAuthentication(), this.getClass())); &#125; if (successHandler != null) &#123; successHandler.onAuthenticationSuccess(request, response, rememberMeAuth); return; &#125; &#125; catch (AuthenticationException authenticationException) &#123; if (logger.isDebugEnabled()) &#123; logger.debug( &quot;SecurityContextHolder not populated with remember-me token, as &quot; + &quot;AuthenticationManager rejected Authentication returned by RememberMeServices: &apos;&quot; + rememberMeAuth + &quot;&apos;; invalidating remember-me token&quot;, authenticationException); &#125; rememberMeServices.loginFail(request, response); onUnsuccessfulAuthentication(request, response, authenticationException); &#125; &#125; chain.doFilter(request, response); &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;SecurityContextHolder not populated with remember-me token, as it already contained: &apos;&quot; + SecurityContextHolder.getContext().getAuthentication() + &quot;&apos;&quot;); &#125; chain.doFilter(request, response); &#125;&#125; AbstractRememberMeServices 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Template implementation which locates the Spring Security cookie, decodes it into a * delimited array of tokens and submits it to subclasses for processing via the * &lt;tt&gt;processAutoLoginCookie&lt;/tt&gt; method. * &lt;p&gt; * The returned username is then used to load the UserDetails object for the user, * which in turn is used to create a valid authentication token. */@Overridepublic final Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) &#123; String rememberMeCookie = extractRememberMeCookie(request); if (rememberMeCookie == null) &#123; return null; &#125; logger.debug(&quot;Remember-me cookie detected&quot;); if (rememberMeCookie.length() == 0) &#123; logger.debug(&quot;Cookie was empty&quot;); cancelCookie(request, response); return null; &#125; UserDetails user = null; try &#123; String[] cookieTokens = decodeCookie(rememberMeCookie); //调用PersistentTokenBasedRememberMeServices的processAutoLoginCookie user = processAutoLoginCookie(cookieTokens, request, response); userDetailsChecker.check(user); logger.debug(&quot;Remember-me cookie accepted&quot;); return createSuccessfulAuthentication(request, user); &#125; catch (CookieTheftException cte) &#123; cancelCookie(request, response); throw cte; &#125; catch (UsernameNotFoundException noUser) &#123; logger.debug(&quot;Remember-me login was valid but corresponding user not found.&quot;, noUser); &#125; catch (InvalidCookieException invalidCookie) &#123; logger.debug(&quot;Invalid remember-me cookie: &quot; + invalidCookie.getMessage()); &#125; catch (AccountStatusException statusInvalid) &#123; logger.debug(&quot;Invalid UserDetails: &quot; + statusInvalid.getMessage()); &#125; catch (RememberMeAuthenticationException e) &#123; logger.debug(e.getMessage()); &#125; cancelCookie(request, response); return null;&#125; PersistentTokenBasedRememberMeServices 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Locates the presented cookie data in the token repository, using the series id. If * the data compares successfully with that in the persistent store, a new token is * generated and stored with the same series. The corresponding cookie value is set on * the response. * * @param cookieTokens the series and token values * * @throws RememberMeAuthenticationException if there is no stored token corresponding * to the submitted cookie, or if the token in the persistent store has expired. * @throws InvalidCookieException if the cookie doesn&apos;t have two tokens as expected. * @throws CookieTheftException if a presented series value is found, but the stored * token is different from the one presented. */protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) &#123; if (cookieTokens.length != 2) &#123; throw new InvalidCookieException(&quot;Cookie token did not contain &quot; + 2 + &quot; tokens, but contained &apos;&quot; + Arrays.asList(cookieTokens) + &quot;&apos;&quot;); &#125; final String presentedSeries = cookieTokens[0]; final String presentedToken = cookieTokens[1]; //通过series去数据库查找token PersistentRememberMeToken token = tokenRepository .getTokenForSeries(presentedSeries); if (token == null) &#123; // No series match, so we can&apos;t authenticate using this cookie throw new RememberMeAuthenticationException( &quot;No persistent token found for series id: &quot; + presentedSeries); &#125; // We have a match for this user/series combination if (!presentedToken.equals(token.getTokenValue())) &#123; // Token doesn&apos;t match series value. Delete all logins for this user and throw // an exception to warn them. tokenRepository.removeUserTokens(token.getUsername()); throw new CookieTheftException( messages.getMessage( &quot;PersistentTokenBasedRememberMeServices.cookieStolen&quot;, &quot;Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.&quot;)); &#125; if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L &lt; System .currentTimeMillis()) &#123; throw new RememberMeAuthenticationException(&quot;Remember-me login has expired&quot;); &#125; // Token also matches, so login is valid. Update the token value, keeping the // *same* series number. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Refreshing persistent login token for user &apos;&quot; + token.getUsername() + &quot;&apos;, series &apos;&quot; + token.getSeries() + &quot;&apos;&quot;); &#125; PersistentRememberMeToken newToken = new PersistentRememberMeToken( token.getUsername(), token.getSeries(), generateTokenData(), new Date()); try &#123; tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); addCookie(newToken, request, response); &#125; catch (Exception e) &#123; logger.error(&quot;Failed to update token: &quot;, e); throw new RememberMeAuthenticationException( &quot;Autologin failed due to data access problem&quot;); &#125; //调用UserDetailsService的loadUserByUsername return getUserDetailsService().loadUserByUsername(token.getUsername());&#125;]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security（三）短信验证码登录]]></title>
    <url>%2Fposts%2F1444918557%2F</url>
    <content type="text"><![CDATA[Spring Security（三）短信验证码登录1. 验证码生成验证码处理流程ValidateCodeProcessor 生成相同的实现在AbstractValidateCodeProcessor,不同的对应不同的实现类 2. 短信登录 2.1. 代码实现2.1.1. SmsAuthenticationToken的实现参考UsernamePasswordAuthenticationToken的实现 2.1.2. SmsAuthenticationProvider的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class SmsCodeAuthenticationProvider implements AuthenticationProvider &#123; private UserDetailsService userDetailsService; /* * (non-Javadoc) * * @see org.springframework.security.authentication.AuthenticationProvider# * authenticate(org.springframework.security.core.Authentication) */ @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; SmsCodeAuthenticationToken authenticationToken = (SmsCodeAuthenticationToken) authentication; //通过手机号读用户信息 UserDetails user = userDetailsService.loadUserByUsername((String) authenticationToken.getPrincipal()); if (user == null) &#123; throw new InternalAuthenticationServiceException(&quot;无法获取用户信息&quot;); &#125; //重新构造SmsCodeAuthenticationToken，设置setAuthenticated为true,user.getAuthorities()为用户的权限 SmsCodeAuthenticationToken authenticationResult = new SmsCodeAuthenticationToken(user, user.getAuthorities()); //将未认证SmsCodeAuthenticationToken的details放入到已认证的SmsCodeAuthenticationToken的details authenticationResult.setDetails(authenticationToken.getDetails()); return authenticationResult; &#125; /* * (non-Javadoc) * AuthenticationManager通过这个处理SmsCodeAuthenticationToken * @see org.springframework.security.authentication.AuthenticationProvider# * supports(java.lang.Class) */ @Override public boolean supports(Class&lt;?&gt; authentication) &#123; //判断传进来的authentication是不是SmsCodeAuthenticationToken return SmsCodeAuthenticationToken.class.isAssignableFrom(authentication); &#125; public UserDetailsService getUserDetailsService() &#123; return userDetailsService; &#125; public void setUserDetailsService(UserDetailsService userDetailsService) &#123; this.userDetailsService = userDetailsService; &#125;&#125; 2.2.3. SmsCodeAuthenticationFilter的实现参考UsernamePasswordAuthenticationFilter的代码 2.2.4. 增加短信登录的配置12345678910111213141516@Overridepublic void configure(HttpSecurity http) throws Exception &#123; SmsCodeAuthenticationFilter smsCodeAuthenticationFilter = new SmsCodeAuthenticationFilter();//设置AuthenticationManager smsCodeAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class)); //设置成功处理器 smsCodeAuthenticationFilter.setAuthenticationSuccessHandler(number47AuthenticationSuccessHandler); //设置失败处理器smsCodeAuthenticationFilter.setAuthenticationFailureHandler(number47AuthenticationFailureHandler); SmsCodeAuthenticationProvider smsCodeAuthenticationProvider = new SmsCodeAuthenticationProvider(); //设置userDetails smsCodeAuthenticationProvider.setUserDetailsService(userDetailsService);//设置短信的provider和过滤器 http.authenticationProvider(smsCodeAuthenticationProvider) .addFilterAfter(smsCodeAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);&#125;]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WireMock伪造REST服务]]></title>
    <url>%2Fposts%2F2041720639%2F</url>
    <content type="text"><![CDATA[WireMock伪造REST服务1. 下载WireMock的jar包官网：http://wiremock.org/docs/running-standalone/ 2. 运行下载的jar指定运行端口为8062 1java -jar wiremock-standalone-2.26.3.jar --port 8062 3. 代码实现WireMock接收请求后返回的什么请求3.1. 导入wirmock的依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt; &lt;artifactId&gt;wiremock&lt;/artifactId&gt; &lt;version&gt;2.26.3&lt;/version&gt;&lt;/dependency&gt; 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.12&lt;/version&gt;&lt;/dependency&gt; 3.2. 写对应的接口地址和响应12345678910111213141516171819202122232425262728293031323334353637package com.number47.wiremock;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.springframework.core.io.ClassPathResource;import java.io.IOException;import static com.github.tomakehurst.wiremock.client.WireMock.*;/** * @author number47 * @date 2020/6/8 23:58 * @description */public class MockServer &#123; public static void main(String[] args) throws IOException &#123; configureFor(8062); //清除以前的配置 removeAllMappings(); //伪造一个测试桩 //请求接口，返回对应json,读取01.txt的文件 mock(&quot;/order/1&quot;, &quot;01&quot;); &#125; public static void mock(String url, String fileName) throws IOException &#123; ClassPathResource resource = new ClassPathResource(&quot;mock/response/&quot; + fileName + &quot;.txt&quot;); String content = StringUtils.join(FileUtils.readLines(resource.getFile(), &quot;UTF-8&quot;).toArray(), &quot;\n&quot;); stubFor(get(urlPathEqualTo(url)) .willReturn(aResponse() .withBody(content) .withStatus(200))); &#125;&#125;]]></content>
      <categories>
        <category>REST</category>
      </categories>
      <tags>
        <tag>REST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式-单例模式]]></title>
    <url>%2Fposts%2F1262053707%2F</url>
    <content type="text"><![CDATA[Java设计模式-单例模式1. 单例模式这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 1.1. 例子有自己要创建单例的静态对象 构造函数为私有 对外提供获取唯一可用的对象的方法 1234567891011121314151617public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 使用： 1234567891011121314public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; 2. 实现方式2.1. 懒汉式，线程不安全是否 Lazy 初始化：是 是否多线程安全：否 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 2.2. 懒汉式，线程安全是否 Lazy 初始化：是 是否多线程安全：是 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 2.3. 饿汉式，线程安全是否 Lazy 初始化：否 是否多线程安全：是 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 2.4. 双检锁/双重校验锁（DCL，即 double-checked locking）是否 Lazy 初始化：是 是否多线程安全：是 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 2.5. 登记式/静态内部类是否 Lazy 初始化：是 是否多线程安全：是 123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 2.6. 枚举是否 Lazy 初始化：否 是否多线程安全：是 12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 建议：不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lesson22-Unit3 Part3(2)]]></title>
    <url>%2Fposts%2F2431835038%2F</url>
    <content type="text"><![CDATA[VocabularySource of Energy 能源solar energy/solar power 太阳能solar adj.太阳的 clean 干净的 -&gt; cleanest 最干净的 plentiful 充足的 -&gt; most plentiful 最充足的 one of + the形容词最高级+名词复数 最….的之一 e.g. Tony Stark is one of the richest people in the world. Solar power depends on sunlight, so in cloudy weather and at night, no power is generated. wind energy 风能non-: 表示否定的前缀 non-polluting 无污染的 non-alcoholoic 不含酒精的 non-traditional 非传统的 non-smoking 无烟的 Wind turbines convert the kinetic energy of the wind into mechanical power. wind turbine 风力涡轮机 mechanical power 机械能 kinetic energy 动能 convert A into B 把A转化为B nuclear energy 核能efficient 高效的 carbon gas 含碳气体 waste product 废弃物 Chernobyl 切尔诺贝利 deadly adj.致命的，致死的 a deadly virus 致命的病毒 a deadly weapon 致命的武器 deadly radioactive waste products 致命的放射性废弃物 fossil fuel 化石燃料A major source of energy comes from the buring of fossil fuels, such as coal and oil. the buring of fossil fuels 化石燃料的燃烧 coal 煤 oil 石油 CO2= carbon dioxide 二氧化碳 When we burn fossil fuels, waste gases, such as CO2 are produced. 当我们燃烧化石燃料时，废弃的气体就产生了，比如二氧化碳。 remain v.保持不变，仍然是 remain + n. e.g. It remains a secret. remain + adj. e.g. You have the right to remain silent. 你有权保持沉默。 hydropower 水力发电the kinetic energy of falling water 高处落下的睡产生的动能 Output is reliable and can be regulated to meet the demand, except during periods of drought. 水力发电的能量稳定，可以调控以满足需求，除了干旱时期之外。 reliable adj.可靠的，可信赖的 output n. 输出，产出 input n. 输入，投入 regulate v.控制调节 e.g. My monther regulates how much TV I can watch. to meet the demand 为了满足需求（动词不定式表示目的） meet v. 满足 meet the needs/requirements except 除…之外 drought n.干旱 Types of Wordsnoun 名词 n.&amp; pronoun代词 pron.represent object a person, an animal, a thing, including an idea verb动词 v.express actions: sit down , stand up express relationships: to love someone , to own something adjective 形容词 adj.describe objects: a tall building adverb 副词 adv.describe actions: run fast,walk slowly, quickly, loudly, quietly, well Adverbs express the quality of an action, such as how well or poorly something is done. conjunction 连接词 conj.connect thing or actions : to read and write Dialogue将来时的结构之一：will do 将来时的结构之二：现在进行时表将来 We are moving to a new office. 我们要搬去新的办公室了. move, go, come, leave 等转移动词 e.g. I’m coming. ​ She’s leaving for Beijing. When is this going to happen? 将来时的结构之三：be going to + do 意愿（打算在将来做某事） e.g. We are going to move to a new office. 我们要搬去新的办公室了. be supposed to do sth 应当做某事 How far away..?有多远 How far away is the new office? How far away … from ..? 从哪到哪距离多远 How far away is the Sun from Earth? We’re not sure yet, but it will mean a longer commute of most of us. yet 用于否定句和疑问句，谈论尚未发生的事 commute n. 通勤 a longer commute v. 通勤 I commute by subway In other words 也就是说，换句话说 That depends on your point of view. point of view 观点，看法 From my point of view …./ In my opinion…. 在我看来.. depend on 取决于 plan to do sth 打算做某事 不定代词+形容词 somthing hot and spicy on one’s own 靠自己 now that 既然，由于 e.g. I‘m going to relax now that the school year is over. 既然一个学年结束了，我想放松下 in favor of sth 支持，赞同某事 be against sth 反对某事 at first 一开始，最开始 be serious about sth. 对某事认真严肃 take a risk/take risks 冒险 be tired of doing sth 厌倦做某事 come as a surprise to sb 让某人出乎意料，感到突然 come as no surprise 不出意外]]></content>
      <categories>
        <category>English</category>
        <category>教学课</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>教学课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security（一）认证流程]]></title>
    <url>%2Fposts%2F1444918557%2F</url>
    <content type="text"><![CDATA[Spring Security（一）认证流程1. 核心功能 认证（你是谁） 授权（你能干什么） 攻击防护（防止伪造身份） 2. 基本原理绿色的可以通过配置控制 3. 自定义用户认证逻辑3.1. 处理用户信息获取逻辑Spring Security的用户获取封装在UserDetailsService1UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; 实现自定义的UserDetailsService1234567891011121314151617181920212223242526272829303132333435363738394041package com.number47.security.browser;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.authority.AuthorityUtils;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;/** * @author number47 * @date 2019/9/2 22:26 * @description */@Componentpublic class MyUserDetailService implements UserDetailsService &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; logger.info(&quot;登录用户名：&quot;+ username); //根据用户名查找信息 //根据查找到的用户信息判断是否被冻结 //User用的是Spring Security的User,已经实现了UserDetails了 return new User(username, passwordEncoder.encode(&quot;123456&quot;), true, true, true, true, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)); &#125;&#125; 3.2. 处理用户校验逻辑实现自己的User对象，实现UserDetails，实现对应的方法 3.3. 处理密码加密解密使用PasswordEncoder 3.4. 处理不同类型的请求请求成功后是重定向到页面还是返回json 4. 认证处理说明4.1. 认证处理流程 UsernamePasswordAuthenticationFilter 1234567UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password);// Allow subclasses to set the &quot;details&quot; propertysetDetails(request, authRequest);//传递UsernamePasswordAuthenticationToken给ProviderManager的authenticate()return this.getAuthenticationManager().authenticate(authRequest); ProviderManager 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283ProviderManager是AuthenticationManager的实现类public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); AuthenticationException lastException = null; Authentication result = null; boolean debug = logger.isDebugEnabled(); //不同的provider所支持的authentication是不一样的,UsernamePasswordAuthenticationFilter传递的是UsernamePasswordAuthenticationToken for (AuthenticationProvider provider : getProviders()) &#123; if (!provider.supports(toTest)) &#123; continue; &#125; if (debug) &#123; logger.debug(&quot;Authentication attempt using &quot; + provider.getClass().getName()); &#125; try &#123; result = provider.authenticate(authentication); if (result != null) &#123; copyDetails(authentication, result); break; &#125; &#125; catch (AccountStatusException e) &#123; prepareException(e, authentication); // SEC-546: Avoid polling additional providers if auth failure is due to // invalid account status throw e; &#125; catch (InternalAuthenticationServiceException e) &#123; prepareException(e, authentication); throw e; &#125; catch (AuthenticationException e) &#123; lastException = e; &#125; &#125; if (result == null &amp;&amp; parent != null) &#123; // Allow the parent to try. try &#123; result = parent.authenticate(authentication); &#125; catch (ProviderNotFoundException e) &#123; // ignore as we will throw below if no other exception occurred prior to // calling parent and the parent // may throw ProviderNotFound even though a provider in the child already // handled the request &#125; catch (AuthenticationException e) &#123; lastException = e; &#125; &#125; if (result != null) &#123; if (eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) &#123; // Authentication is complete. Remove credentials and other secret data // from authentication ((CredentialsContainer) result).eraseCredentials(); &#125; eventPublisher.publishAuthenticationSuccess(result); return result; &#125; // Parent was null, or didn&apos;t authenticate (or throw an exception). if (lastException == null) &#123; lastException = new ProviderNotFoundException(messages.getMessage( &quot;ProviderManager.providerNotFound&quot;, new Object[] &#123; toTest.getName() &#125;, &quot;No AuthenticationProvider found for &#123;0&#125;&quot;)); &#125; prepareException(lastException, authentication); throw lastException; &#125; DaoAuthenticationProvider 12345678910111213141516171819202122232425262728protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; UserDetails loadedUser; try &#123; //调用了loadUserByUsername loadedUser = this.getUserDetailsService().loadUserByUsername(username); &#125; catch (UsernameNotFoundException notFound) &#123; if (authentication.getCredentials() != null) &#123; String presentedPassword = authentication.getCredentials().toString(); passwordEncoder.isPasswordValid(userNotFoundEncodedPassword, presentedPassword, null); &#125; throw notFound; &#125; catch (Exception repositoryProblem) &#123; throw new InternalAuthenticationServiceException( repositoryProblem.getMessage(), repositoryProblem); &#125; if (loadedUser == null) &#123; throw new InternalAuthenticationServiceException( &quot;UserDetailsService returned null, which is an interface contract violation&quot;); &#125; return loadedUser;&#125; DaoAuthenticationProvider的一些实现写在AbstractUserDetailsAuthenticationProvider 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;, &quot;Only UsernamePasswordAuthenticationToken is supported&quot;)); // Determine username String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot; : authentication.getName(); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if (user == null) &#123; cacheWasUsed = false; try &#123; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (UsernameNotFoundException notFound) &#123; logger.debug(&quot;User &apos;&quot; + username + &quot;&apos; not found&quot;); if (hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); &#125; else &#123; throw notFound; &#125; &#125; Assert.notNull(user, &quot;retrieveUser returned null - a violation of the interface contract&quot;); &#125; try &#123; preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (AuthenticationException exception) &#123; if (cacheWasUsed) &#123; // There was a problem, so try again after checking // we&apos;re using latest data (i.e. not from the cache) cacheWasUsed = false; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; else &#123; throw exception; &#125; &#125; postAuthenticationChecks.check(user); if (!cacheWasUsed) &#123; this.userCache.putUserInCache(user); &#125; Object principalToReturn = user; if (forcePrincipalAsString) &#123; principalToReturn = user.getUsername(); &#125; return createSuccessAuthentication(principalToReturn, authentication, user);&#125; AbstractAuthenticationProcessingFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; if (!requiresAuthentication(request, response)) &#123; chain.doFilter(request, response); return; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Request is to process authentication&quot;); &#125; Authentication authResult; try &#123; //调用 authResult = attemptAuthentication(request, response); if (authResult == null) &#123; // return immediately as subclass has indicated that it hasn&apos;t completed // authentication return; &#125; sessionStrategy.onAuthentication(authResult, request, response); &#125; catch (InternalAuthenticationServiceException failed) &#123; logger.error( &quot;An internal error occurred while trying to authenticate the user.&quot;, failed); //认证失败 unsuccessfulAuthentication(request, response, failed); return; &#125; catch (AuthenticationException failed) &#123; // Authentication failed unsuccessfulAuthentication(request, response, failed); return; &#125; // Authentication success if (continueChainBeforeSuccessfulAuthentication) &#123; chain.doFilter(request, response); &#125; successfulAuthentication(request, response, chain, authResult);&#125; 4.2. 认证结果如何在多个请求之间共享放在session,什么时候放入session,放入了什么，什么时候读出 AbstractAuthenticationProcessingFilter 123456789101112131415161718192021protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Authentication success. Updating SecurityContextHolder to contain: &quot; + authResult); &#125; //认证成功后将结果放入到SecurityContext里 SecurityContextHolder.getContext().setAuthentication(authResult); rememberMeServices.loginSuccess(request, response, authResult); // Fire event if (this.eventPublisher != null) &#123; eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent( authResult, this.getClass())); &#125; successHandler.onAuthenticationSuccess(request, response, authResult);&#125; SecurityContextImpl是SecurityContext的实现类 包装了Authentication，重写了equals和hashCode，保证唯一性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* * Copyright 2004, 2005, 2006 Acegi Technology Pty Limited * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.security.core.context;import org.springframework.security.core.Authentication;import org.springframework.security.core.SpringSecurityCoreVersion;/** * Base implementation of &#123;@link SecurityContext&#125;. * &lt;p&gt; * Used by default by &#123;@link SecurityContextHolder&#125; strategies. * * @author Ben Alex */public class SecurityContextImpl implements SecurityContext &#123; private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; // ~ Instance fields // ================================================================================================ private Authentication authentication; // ~ Methods // ======================================================================================================== public boolean equals(Object obj) &#123; if (obj instanceof SecurityContextImpl) &#123; SecurityContextImpl test = (SecurityContextImpl) obj; if ((this.getAuthentication() == null) &amp;&amp; (test.getAuthentication() == null)) &#123; return true; &#125; if ((this.getAuthentication() != null) &amp;&amp; (test.getAuthentication() != null) &amp;&amp; this.getAuthentication().equals(test.getAuthentication())) &#123; return true; &#125; &#125; return false; &#125; public Authentication getAuthentication() &#123; return authentication; &#125; public int hashCode() &#123; if (this.authentication == null) &#123; return -1; &#125; else &#123; return this.authentication.hashCode(); &#125; &#125; public void setAuthentication(Authentication authentication) &#123; this.authentication = authentication; &#125; public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(super.toString()); if (this.authentication == null) &#123; sb.append(&quot;: Null authentication&quot;); &#125; else &#123; sb.append(&quot;: Authentication: &quot;).append(this.authentication); &#125; return sb.toString(); &#125;&#125; SecurityContextHolder是什么？ SecurityContextHolder是ThreadLocal的封装,ThreadLocal是跟线程绑定的map,在同一个线程里，在这个方法往ThreadLocal放入的东西，在另外一个方法是可以读出来的，可以理解为线程级的程序变量。 一般请求和响应是在同一个线程进行的。 通过SecurityContextPersistenceFilter检查线程，如果请求进来的时候如果有认证信息放入到session,响应的时候有认证信息放入到session里。 4.3. 获取认证用户信息1234567891011121314151617181920212223242526/** * 获取个人信息方式1 * @return */@GetMapping(&quot;/me&quot;)public Object getCurrentUser()&#123; return SecurityContextHolder.getContext().getAuthentication();&#125;/** * 获取个人信息方式2 * @return */@GetMapping(&quot;/me2&quot;)public Object getCurrentUser(Authentication authentication)&#123; return authentication;&#125;/** * 获取Authentication的Principal * @return */@GetMapping(&quot;/me3&quot;)public Object getCurrentUser(@AuthenticationPrincipal UserDetails user)&#123; return user;&#125;]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专项课18 旅游场景]]></title>
    <url>%2Fposts%2F3125715510%2F</url>
    <content type="text"><![CDATA[专项课18 旅游场景I’d like a room. 我想开一个房间。 I’d like to reserve a room. 我想开一个房间。 Do you have a reservation? 你有预定吗？ part1：酒店英文out of…表示什么没了eg:We’re out of shampoo and shower gel.我们没有洗发水和沐浴露了。 I‘d like ..表示想要什么And I’d like an extra blanket and towel. 我还要一条毯子和毛巾。 sth doesn’t work 表示什么东西坏了。eg: The AC doesn’t work.空调坏了。 The TV doesn’t work./The TV set doesn’t work.电视机坏了。 The TV: 电视机或电视机节目 The TV set: 电视机机器（更为准确） My key card doesn’t work. 我的房卡坏了。 send someone 表示叫人/派人/送人check it out 看一看，看一下 Could you send someone to check it out? 你们能不能派个人过来看看？ Could you send someone to pick up the food tray? 能叫个人收一下餐盘吗？ Hi,I’am going out and I’ll be back in the evening,can you send someone to clean my room? 我就要出门，晚上回来，你能派人做一下房间清理吗？ Part2 ：交通出行请求酒店帮忙预定出租车Can you book a taxi for me? I’d like to go to Times Square tomorrow morning at 9. 你能帮我预定一辆出租车吗？我明天早上九点要去时代广场。 自己打车，跟司机交流Where are you heading to? 你去哪儿？ Where to? 去哪儿？ get in上车 赶时间I’m really in a hurry. Is there a shortcut? 问司机有没有小路/捷径可以快点？ tap on:刷卡上车 tap off:刷卡下车 Part3：求助外国人拍照时提出自己的小需求Excuse me, can you take a photo for us please? 不好意思，你能帮我们拍张照吗？ Can/Could you take that building in please? 你能帮我把那个建筑拍进去吗？ 借手机打电话Excuse me, my phone is dead, Can I use you phone for a sec. I can’t find my friend, and I need to make a call. 不好意思，我手机没电了，能借你手机打个电话吗？很快的，我找不到我朋友了，需要打个电话。 找人帮忙给手机充电Can you help me charge my phone? It’s dead. 你能帮我充电吗？没电了]]></content>
      <categories>
        <category>English</category>
        <category>专项课</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>专项课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring security 学习(一)-spring boot 整合]]></title>
    <url>%2Fposts%2F2041720639%2F</url>
    <content type="text"><![CDATA[Spring Security(一)-Spring Boot 整合创建spring boot项目，引入spring-boot-start-security1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 创建/spring-security的访问接口1234567@RestControllerpublic class DemoController &#123; @GetMapping("spring-security") public String hello() &#123; return "hello spring security"; &#125;&#125; 表单认证创建配置类WebSecurityConfig继承WebSecurityConfigurerAdapter,WebSecurityConfigurerAdapter是由Spring Security提供的Web应用安全配置的适配器。 1234567891011121314@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单方式 .and() .authorizeRequests() .anyRequest() // 所有请求 .authenticated(); // 都需要认证 &#125;&#125; 设置启动端口application.properties 1server.port=8081 启动程序，启动时控制台Using generated security password: 9aac6105-0752-4bf1-9f54-c247e94086ab，每次都不一样，这个为用户user的密码。访问http://localhost:8080/spring-security，页面跳转到http://localhost:8080/login登录后，访问到http://localhost:8080/spring-security]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rest API的拦截]]></title>
    <url>%2Fposts%2F1757692245%2F</url>
    <content type="text"><![CDATA[Rest API的拦截拦截顺序filter-&gt;Interceptor-&gt;Aspect 异常捕获顺序Aspect-&gt;ControllerAdvice-&gt;Inteceptor-&gt;filter 过滤器（Filter）可以获取到原始http请求和响应的信息，但是取不到处理方法的信息 自定义Filter spring boot添加@Component1234567891011121314151617181920212223242526272829303132333435package com.number47.com.number47.filter;import org.springframework.stereotype.Component;import javax.servlet.*;import java.io.IOException;import java.util.Date;/** * @author number47 * @date 2019/8/18 23:44 * @description Rest API filter */@Componentpublic class TimeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("time filter init"); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("time filter start"); long start = new Date().getTime(); filterChain.doFilter(servletRequest,servletResponse); System.out.println("time filter：" + (new Date().getTime()-start)); System.out.println("time filter finish"); &#125; @Override public void destroy() &#123; System.out.println("time filter destroy"); &#125;&#125; 加入第三方Filter spring boot12345678910111213141516171819202122232425262728package com.number47.com.number47.config;import com.number47.com.number47.filter.TimeFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import java.util.ArrayList;import java.util.List;/** * @author number47 * @date 2019/8/18 23:53 * @description */@Configurationpublic class WebConfig &#123; @Bean public FilterRegistrationBean timeFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); TimeFilter timeFilter = new TimeFilter(); registrationBean.setFilter(timeFilter); List&lt;String&gt; urls = new ArrayList&lt;&gt;(); urls.add(&quot;/*&quot;); registrationBean.setUrlPatterns(urls); return registrationBean; &#125;&#125; 拦截器(Interceptor)可以获取到原始http请求和响应的信息，可以获取处理方法的信息，但是获取不到参数的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.number47.com.number47.interceptor;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Date;/** * @author number47 * @date 2019/8/19 00:01 * @description */@Componentpublic class TimeInterceptor implements HandlerInterceptor &#123; /** * controller 之前调用 * @param httpServletRequest * @param httpServletResponse * @param handle * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handle) throws Exception &#123; System.out.println("preHandle"); System.out.println(((HandlerMethod)handle).getBean().getClass().getName()); System.out.println(((HandlerMethod)handle).getMethod().getName()); httpServletRequest.setAttribute("startTime",new Date().getTime()); return true; &#125; /** * controller 方法处理之后调用，如果controller抛出异常，这个方法不会调用 * @param httpServletRequest * @param httpServletResponse * @param o * @param modelAndView * @throws Exception */ @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle"); Long start = (Long)httpServletRequest.getAttribute("startTime"); System.out.println("time interceptor 耗时：" + (new Date().getTime() - start)); &#125; /** * controller 无论是正常还是抛出异常都会调用 * @param httpServletRequest * @param httpServletResponse * @param o * @param e * @throws Exception */ @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; System.out.println("afterCompletion"); Long start = (Long)httpServletRequest.getAttribute("startTime"); System.out.println("time interceptor 耗时：" + (new Date().getTime() - start)); System.out.println("exception is " + e); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.number47.com.number47.config;import com.number47.com.number47.filter.TimeFilter;import com.number47.com.number47.interceptor.TimeInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import java.util.ArrayList;import java.util.List;/** * @author number47 * @date 2019/8/18 23:53 * @description */@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired private TimeInterceptor timeInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(timeInterceptor); &#125;&#125; 切片(Aspect)获取不到原始http请求和响应的信息，可以获取参数的值 Spring Aop简介 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.number47.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Date;/** * @author number47 * @date 2019/8/19 00:29 * @description */@Aspect@Componentpublic class TimeAspect &#123; @Before(value = &quot;execution(* com.number47.web.controller.UserController.*(..))&quot;) public void before()&#123; System.out.println(&quot;方法调用之前&quot;); &#125; @After(value = &quot;execution(* com.number47.web.controller.UserController.*(..))&quot;) public void after()&#123; System.out.println(&quot;方法调用之后&quot;); &#125; @AfterThrowing(value = &quot;execution(* com.number47.web.controller.UserController.*(..))&quot;) public void afterThrowing()&#123; System.out.println(&quot;方法异常调用之后&quot;); &#125; @Around(value = &quot;execution(* com.number47.web.controller.UserController.*(..))&quot;) public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;time aspect start&quot;); long start = new Date().getTime(); Object object = proceedingJoinPoint.proceed(); Object[] args = proceedingJoinPoint.getArgs(); for (Object arg: args)&#123; System.out.println(&quot;arg is &quot; + arg); &#125; System.out.println(&quot;time aspect：&quot; + (new Date().getTime()-start)); System.out.println(&quot;包含上面所有情况&quot;); System.out.println(&quot;time aspect end&quot;); return object; &#125;&#125;]]></content>
      <tags>
        <tag>Rest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate Validator]]></title>
    <url>%2Fposts%2F2291746956%2F</url>
    <content type="text"><![CDATA[Hibernate Validator 注解 作用 @Null 值必须为空 @Pattern(regex=) 字符串必须匹配正则表达式 @Size(min=,max=) 集合的元素数量必须在min和max之间 @CreditCardNumber(ignoreNonDigitCharacters) 字符串必须是信用卡号（按美国的标准验证的） @Email 字符串必须是Email地址 @Length(min=,max=) 检查字符串的长度 @NotBlank 字符串必须有字符 @NotEmpty 字符串不为null,集合有元素 @Range(min=,max=) 数字必须大于等于min,小于等于max @SafeHtml 字符串是安全的html @URL 字符串是合法的URL @NotNull 值不能为空 @AssertFalse 值必须为false @AssertTrue 值必须为true @DecimalMax(value=,inclusive=) 值必须小于等于（inclusive=true）/小于（inclusive=false）value属指定的值，可以注解在字符串类型的属性上 @DecimalMin(value=,inclusive=) 值必须大于等于（inclusive=true）/大于（inclusive=false）value属指定的值，可以注解在字符串类型的属性上 @Digits(integer=,fraction=) 数字格式检查。integer指定整数部分的最大长度，fraction指定小数部分的最大长度 @Future 值必须是未来的日期 @Past 值必须是过去的日期 @Max(value=) 值必须小于等于value指定的值。不能注解在字符串类型的属性上。 @Min(value=) 值必须大于等于value指定的值。不能注解在字符串类型的属性上。 通过@Valid,BindingResult使用校验/@JsonView指定属性的显示Public class User{ 123public interface UserSimpleView&#123;&#125;;public interface UserDetailView extends UserSimpleView&#123;&#125;; 123456789101112131415161718192021222324 /** * @NotBlank校验不为空 */@NotBlankprivate String password;private String userName;@JsonView(UserSimpleView.class)public String getUserName() &#123; return userName;&#125;public void setUserName(String userName) &#123; this.userName = userName;&#125;@JsonView(UserDetailView.class)public String getPassword() &#123; return password;&#125;public void setPassword(String password) &#123; this.password = password;&#125; } 123456789101112131415161718192021222324252627282930313233@RestController@RequestMapping("/user")public class UserController &#123; @PostMapping @JsonView(User.UserSimpleView.class) //显示名称 public User userCreate(@Valid @RequestBody User user, BindingResult errors)&#123; //捕获没有通过校验的错误 if (errors.hasErrors())&#123; errors.getAllErrors().stream().forEach(error -&gt; System.out.println(error.getDefaultMessage())); &#125; System.out.println(user.getId()); System.out.println(user.getUserName()); System.out.println(user.getPassword()); System.out.println(user.getBirthDay()); user.setId("1"); return user; &#125; /** * * @param userId 通过正则表达式 只能接受数字 * @return */ @GetMapping("/&#123;id:\\d+&#125;") @JsonView(User.UserDetailView.class) //显示名称和密码 public User getInfo(@PathVariable(name = "id") String userId)&#123; User user = new User(); user.setUserName("JOJO"); return user; &#125;&#125;]]></content>
      <categories>
        <category>Hibernate Validator</category>
      </categories>
      <tags>
        <tag>Hibernate Validator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导入import com.sun.rowset.CachedRowSetImpl，报错]]></title>
    <url>%2Fposts%2F3929613669%2F</url>
    <content type="text"><![CDATA[报错内容Access restriction: The type CachedRowSetImpl is not accessible due to restriction on required library C:\glassfish3\jdk7\jre\lib\rt.jar 解决方法项目右键project build path中先移除JRE System Library，再添加库JRE System Library，之后就可以了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JAVA Web问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2Fposts%2F335668945%2F</url>
    <content type="text"><![CDATA[doGet()当浏览器使用get方式提交数据的时候，servlet需要提供doGet()方法。哪些是get方式呢？ form默认的提交方式 如果通过一个超链访问某个地址 如果在地址栏直接输入某个地址 ajax指定使用get方式的时候doPost()当浏览器使用post方式提交数据的时候，servlet需要提供doPost()方法 哪些是post方式呢？ 在form上显示设置 method=”post”的时候 ajax指定post方式的时候service()在执行doGet()或者doPost()之前，都会先执行service()。由service()方法进行判断，到底该调用doGet()还是doPost()。可以发现，service(), doGet(), doPost() 三种方式的参数列表都是一样的。所以，有时候也会直接重写service()方法，在其中提供相应的服务，就不用区分到底是get还是post了。 生命周期一个Servlet的生命周期由 实例化，初始化，提供服务，销毁，被回收几个步骤组成。 requestrequest对象的类是HttpServletRequest，提供了很多有实用价值的方法。 request常见方法request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名” +request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr(): 浏览器所处于的客户机的IP地址request.getRemoteHost(): 浏览器所处于的客户机的主机名request.getRemotePort(): 浏览器所处于的客户机使用的网络端口request.getLocalAddr(): 服务器的IP地址request.getLocalName(): 服务器的主机名request.getMethod(): 得到客户机请求方式一般是GET或者POST。 获取参数request.getParameter(): 是常见的方法，用于获取单值的参数request.getParameterValues(): 用于获取具有多值得参数，比如注册的时候提交的爱好，可以使多选的。request.getParameterMap(): 用于遍历所有的参数，并返回Map类型。 获取头信息request.getHeader() 获取浏览器传递过来的头信息。比如getHeader(“user-agent”) 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息。 responseresponse是HttpServletResponse的实例，用于提供给浏览器的响应信息。 设置响应内容response.getWriter() 通过response.getWriter(); 获取一个PrintWriter 对象。可以使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。]]></content>
      <categories>
        <category>Java_Web</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流]]></title>
    <url>%2Fposts%2F4275355671%2F</url>
    <content type="text"><![CDATA[流的分类按流的流向输入流：只能从中读取数据，而不能向其写入数据。 输出流：只能从中写入数据，而不能向其读取数据。 按操作数据分类字符流：数据单元16位的字符。Reader和Writer作为基类。 字节流：数据单元8位的字节。InputStream和OutputStream作为基类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-IO]]></title>
    <url>%2Fposts%2F1262053707%2F</url>
    <content type="text"><![CDATA[Java基础-IO1. Java IOJava输入/输出系统 区分 Java 的输入和输出：把自己当成程序， 当你从外边读数据到自己这里就用输入（InputStream/Reader）， 向外边写数据就用输出（OutputStream/Writer）。 Stream: Java 中将数据的输入输出抽象为流，流是一组有顺序的，单向的，有起点和终点的数据集合，就像水流。按照流中的最小数据单元又分为字节流和字符流。 1，字节流：以 8 位（即 1 byte，8 bit）作为一个数据单元，数据流中最小的数据单元是字节。 2，字符流：以 16 位（即 1 char，2 byte，16 bit）作为一个数据单元，数据流中最小的数据单元是字符， Java 中的字符是 Unicode 编码，一个字符占用两个字节。 Java IO常用流类 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转化流 InputStreamReader OutStreamWriter 对象流 ObjectInputStream ObjectOutputStream 抽象基类 FilterInputStream PushbackReader 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DateOutputStream 2. IO分类2.1. 根据流向分类输入流（InputStream/Reader） 输出流（OutputStream/Writer） 2.2. 根据数据不同的操作单元分类字节流（InputStream/OutputStream） 字符流 (Reader/Writer） 2.2.1. 字节流字节输入流 InputStream 是所有的输入字节流的父类，它是一个抽象类。 PushbackInputStream、DataInputStream 和 BufferedInputStream都是处理流，他们的的父类是 FilterInputStream。 ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从 Byte 数组、StringBuffer、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据。 InputStream 中的三个基本的读方法 abstract int read() ：读取一个字节数据，并返回读到的数据，如果返回 -1，表示读到了输入流的末尾。 int read(byte[] b)：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回-1，表示读到了输入流的末尾。 int read(byte[] b, int off, int len) ：将数据读入一个字节数组，同时返回实际读取的字节数。如果返回 -1，表示读到了输入流的末尾。off 指定在数组 b 中存放数据的起始偏移位置；len 指定读取的最大字节数。 字节输出流 OutputStream 是所有的输出字节流的父类，它是一个抽象类。 ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向 Byte 数组、和本地文件中写入数据。 PipedOutputStream 是向与其它线程共用的管道中写入数据。 BufferedOutputStream、DataOutputStream 和 PrintStream 都是处理流，他们的的父类是 FilterOutputStream。 OutputStream 中的基本的写方法** abstract void write(int b)：往输出流中写入一个字节。 void write(byte[] b)：往输出流中写入数组b中的所有字节。 void write(byte[] b, int?off, int?len) ：往输出流中写入数组 b 中从偏移量 off 开始的 len个字节的数据。 void flush()：刷新输出流，强制缓冲区中的输出字节被写出。 void close()：关闭输出流，释放和这个流相关的系统资源。 2.2.2. 字符流字符输入流 Reader 是所有的输入字符流的父类，它是一个抽象类。 CharReader、StringReader是两种基本的介质流，它们分别将 Char 数组、String 中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。 BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它 Reader 对象。 FilterReader 是所有自定义具体装饰流的父类，其子类 PushbackReader 对 Reader 对象进行装饰，会增加一个行号。 InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。 Reader 中的三个基本的读方法 public int read() throws IOException; 读取一个字符，返回值为读取的字符。 public int read(char cbuf[]) throws IOException; 读取一系列字符到数组 cbuf[]中，返回值为实际读取的字符的数量。 public abstract int read(char cbuf[],int off,int len) throws IOException; 读取 len 个字符，从数组 cbuf[] 的下标 off 处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现。 字节输出流 Writer 是所有的输出字符流的父类，它是一个抽象类。 CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向 Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据。 BufferedWriter 是一个装饰器为 Writer 提供缓冲功能。 PrintWriter和 PrintStream 极其类似，功能和使用也非常相似。 OutputStreamWriter 是 OutputStream 到 Writer 转换的桥梁，它的子类 FileWriter其实就是一个实现此功能的具体类。 Writer 中的写方法** public void write(int c) throws IOException； //写单个字符 public void write(char cbuf[]) throws IOException； //将字符数组 cbuf[] 写到输出流 。 public abstract void write(char cbuf[],int off,int len) throws IOException； //将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流 。 public void write(String str) throws IOException； //将字符串str中的字符写入输出流 。 public void write(String str,int off,int len) throws IOException； //将字符串 str 中从索引 off 开始处的 len 个字符写入输出流 2.3. 根据是否直接处理数据节点流：真正直接处理数据的 处理流：装饰加工节点流的 2.3.1. 节点流 文件流：FileInputStream，FileOutputStream，FileReader，FileWriter，它们都会直接操作文件，直接与 OS 底层交互。因此他们被称为节点流 ，注意：使用这几个流的对象之后，需要关闭流对象，因为 java 垃圾回收器不会主动回收。不过在 Java7 之后，可以在 try() 括号中打开流，最后程序会自动关闭流对象，不再需要显示地 close。 数组流：ByteArrayInputStream，ByteArrayOutputStream，CharArrayReader，CharArrayWriter，对数组进行处理的节点流。 字符串流：StringReader，StringWriter，其中StringReader能从 String 中读取数据并保存到 char 数组。 管道流：PipedInputStream，PipedOutputStream，PipedReader，PipedWrite，对管道进行处理的节点流。 2.3.2. 处理流处理流是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如 BufferedReader。 处理流的构造方法总是要带一个其他的流对象做参数。 常用处理流（通过关闭处理流里面的节点流来关闭处理流） 缓冲流 ：BufferedImputStream，BufferedOutputStream，BufferedReader ，BufferedWriter，需要父类作为参数构造，增加缓冲功能，避免频繁读写硬盘，可以初始化缓冲数据的大小，由于带了缓冲功能，所以就写数据的时候需要使用 flush 方法，另外，BufferedReader 提供一个 readLine( )方法可以读取一行，而 FileInputStream 和 FileReader 只能读取一个字节或者一个字符，因此 BufferedReader 也被称为行读取器。 转换流：InputStreamReader，OutputStreamWriter，要 inputStream 或OutputStream 作为参数，实现从字节流到字符流的转换，我们经常在读取键盘输入（System.in）或网络通信的时候，需要使用这两个类。 数据流：DataInputStream，DataOutputStream，提供将基础数据类型写入到文件中，或者读取出来。 3. File创建文件对象注：只是创建File对象，以下程序并不会在文件系统中创建这些目录或文件。 123456789101112131415package io;import java.io.File;public class CreateFile &#123; public static void main(String[] args) &#123; // 绝对路径 File f1 = new File(&quot;d:/TestFolder&quot;); System.out.println(&quot;f1的绝对路径：&quot; + f1.getAbsolutePath()); // 相对路径,相对于工作目录，如果在eclipse中，就是项目目录 File f2 = new File(&quot;text.exe&quot;); System.out.println(&quot;f2的绝对路径：&quot; + f2.getAbsolutePath()); // 把f1作为父目录创建文件对象 File f3 = new File(f1, &quot;text.exe&quot;); System.out.println(&quot;f3的绝对路径：&quot; + f3.getAbsolutePath()); &#125;&#125; 4. File常用方法访问文件名相关的方法 String getName()：返回此File对象所表示的文件名或路径名（如果是路径，则返回最后一级子路径名）。 String getPath()：返回此File对象所对应的路径名。 File getAbsoluteFile()：返回此File对象的绝对路径。 String getAbsolutePath()：返回此File对象所对应的绝对路径名。 String getParent()：返回此File对象所对应目录（最后一级子目录）的父目录名。 boolean ranameTo(File newName)：重命名此File对象所对应的文件或目录。 文件检测相关的方法 boolean exists()：判断File对象所对应的文件或目录是否存在。 boolean canWrite()：判断File对象所对应的文件或目录是否可写。 boolean canRead()：判断File对象所对应的文件或目录是否可读。 boolean isFile()：判断File对象所对应的是文件，而不是目录。 boolean isDirectory()：判断File对象所对应的是否是目录，而不是文件。 获取常规文件信息 long lastModified()：返回文件的最后修改时间。 long length()：返回文件内容的长度。 boolean setLastModified(long time)：设置文件或目录的最后修改时间。 文件操作相关的方法 boolean creatNewFile()：当此FIle对象所对应的文件不存在时，该方法将新建一个该File对象所指定的新文件。 boolean delete()：删除File对象所对应的文件或路径。 ##目录操作相关的方法 boolean mkdir()：创建一个File对象所对应的目录。 boolean mkdirs()：创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。 String[] list()：列出File对象的所有子文件名和路径名，返回String数组。 File[] listFiles()：列出File对象的所有子文件名和路径名，返回File数组。 static File[] listRoot()：列出系统所有根路径。 5. Java IO 常见面试题 字节流和字符流的区别？ 读写单位不同：字节流以字节（8 bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。 处理对象不同：字节流能处理所有类型的数据（如图片、avi 等），而字符流只能处理字符类型的数据。 字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用 colse() 方法时，信息已经输出了，而字符流只有在调用 close() 方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用 flush() 方法。 什么是节点流，什么是处理流,它们各有什么用处，处理流的创建有什么特征？ 见上文：节点流和处理流； 注意：处理流的构造器必须要 传入节点流的子类 什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作？ 对象序列化：Java 对象转换成与平台无关的二进制流； 反序列化：将二进制流恢复成原来的 Java 对象读取； 实现 serializable 接口可以实现对象序列化，其中没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。 例如，在 web 开发中，如果对象被保存在了 Session 中，tomcat 在重启时要把 Session 对象序列化到硬盘，这个对象就必须实现 Serializable 接口。如果对象要经过分布式系统进行网络传输，被传输的对象就必须实现 Serializable 接口。 什么是 Filter 流有哪些？ FilterStream 是一种 IO 流，主要作用是用来对存在的流增加一些额外的功能，像给目标文件增加源文件中不存在的行数，或者增加拷贝的性能等。在 java.io 包中主要由 4 个可用的 filter Stream。两个字节 filter stream，两个字符 filter stream. 分别是：FilterInputStream，FilterOutputStream，FilterReader and FilterWriter. 这些类是抽象类，不能被实例化的。 FilterInputStream 流的子类： DataInputStream 可以把包括基本类型在内的数据和字符串按顺序从数据源读入，它有一些特殊的方法如 readInt()，readDouble() 和 readLine() 等可以读取一个 int，double 和一个 string。 BufferedInputStream 增加性能。 PushbackInputStream 推送要求的字节到系统中。 注：其它子类见 Java io 分类图。 6.说说 RandomAccessFile? 它在 java.io 包中是一个特殊的类，既不是输入流也不是输出流，它两者都可以做到。他是 Object 的直接子类。通常来说，一个流只有一个功能，要么读，要么写。但是 RandomAccessFile 既可以读文件，也可以写文件。 而且 RandomAccessFile 支持对文件的随机访问，实例可见上文：例 5，随机读写文件。 流式部分概括为：两对应一桥梁一随机。 字节流（Byte Stream）和字符流（Char Stream）的对应； 输入和输出的对应。 一个桥梁指：从字节流到字符流的桥梁。对应于输入和输出为InputStreamReader和OutputStreamWriter； 一个随机是：RandomAccessFile。可以随机读取文件。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL数据类型]]></title>
    <url>%2Fposts%2F344462107%2F</url>
    <content type="text"><![CDATA[SQL数据类型 CHAR(n)：定长数据类型 VARCHAR(n)：变长数据类型，n表示字段能够保存的最多字符数量 BLOB：大对象类型，二进制大对象，保存很长的二进制字符串 TEXT：长字符串类型，可以看作一个大VARCHAR字段 数值类型 BIT(n) BIT VARCHAR(n) DECIMAL(p, s) INTEGER SMALLINT BIGINT FLOAT(p, s) DOUBLE PRECISION(p, s) REAL(s)p表示字段的最大长度s表示小数点后面的位数 小数点类型DECIMAL(p, s) p：有效位数 s：标度 12eg:DECIMAL(4,2) 最大值为99.99//有效位数是4，也就是数值总位数是4，标度是2小数点后面的位数 如果实际数值的小数位数超出定义的位数，数字就会被四舍五入。 ##浮点数 REAL：单精度浮点数，单精度浮点数的有效位1—21（包含） DOUBLE PRECISION：双精度浮点数的有效位22—53（包含） 日期和时间类型 DATE TIME DATETIME TIMESTAMP ##直义字符串 一系列字符，比如姓名或电话号码，这是有用户或程序明确指定的。 自定义类型由用户定义的类型，允许用户根据已有的数据类型来定制自己的数据类型。 1234567891011MYSQL//创建自定义类型CRATE TYPE PERSON AS OBJECT(NAME VARCHAR(30),SSN VARCHAR(9));//引用自定义类型CREATE TABLE EMP_PAY(EMPLOYEE PERSON,SALARY DECIMAL(10,2),HIRE_DATE DATE); 域域是能够被使用的有效数据类型的集合。域与数据相关联，从而只接受待定的数据，在域创建之后，我们可以向域添加约束，约束与数据类型共同发挥作用，从而限制字段能够接受的数据。 123456789101112//创建域CREATE DOMAIN MONEY_D AS NUMBER(8,2);//添加约束ALTER DOMAIN MONEY_DADD CONSTRANINT MONEY_CON1CHECK (VALUE &gt; 5);//引用域CREATE TABLE EMP_PAY(EMP_ID NUMBER(9),EMP_NAME VARCHAR2(30),PAY_RATE MONET_D);]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL数据库查询]]></title>
    <url>%2Fposts%2F2950692053%2F</url>
    <content type="text"><![CDATA[Select语句数据库查询语句(DQL) 1234select [* | distinct column1 , column2 ]from table [,table2]where [condition1 | expression1] [and | orcondition2 | expression2 ]order by column1 | integer [ASC升序 | DESC降序] distinct：在结果中去除重复的记录。order by：输出结果以某种形式排序。默认升序ascorder by可以使用整数代表字段eg: 123456789101112select *from products_tblorder by 1;//上面查询语句输出的会按照products_tbl的第一个字段进行升序排序。select *from products_tblorder by 1，2;//上面查询语句输出的会先对products_tbl的第一个字段进行升序排序，再对第二个字段进行升序排序。select *from products_tblorder by 1，2 desc;//上面查询语句输出的会先对products_tbl的第一个字段进行升序排序，再对第二个字段进行降序排序。 统计表里的记录数量COUNT()12345select COUNT(*)from table_name;//查询table_name的表中有多少行数据如果统计的字段规定not null，那么统计结果和表里的数量相同如果统计字段规定可以null，那么就只统计有数据的数据。 eg： 123select COUNT(PROD_ID)from PRODUCTS_TBL;//统计PRODUCTS_TBL里字段PROD_ID的值的数量 使用字段别名12select column_name alias_name(别名)from table_name eg: 12select prod_desc, prod_desc productfrom products_tbl;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基本概念]]></title>
    <url>%2Fposts%2F1750339182%2F</url>
    <content type="text"><![CDATA[概念DBMS（数据库管理系统）数据库管理系统，数据被保存在数据库中，这种机制叫做数据库管理系统。 RDBMS:关系型数据库管理系统。 DBA（数据库管理员）数据库管理员 DBS(数据库系统)由数据库、数据库管理系统（及其应用的开发工具）、应用数据和DBA组成的存储、管理、处理和维护数据的系统。 SQL结构化查询语句是与关系型数据库进行通信的标准语言。 SQL会话用户利用SQL命令与关系型数据库进行交互时发生的事情。当用户与数据库建立连接时，会话就被建立了。会话可以通过直接与数据库建立链接来申请，也可以通过前端程序来申请。无论何种情况，会话通常是由通过网络访问数据库的用户在终端或工作站建立的。 CONNECT命令CONNECT用于建立与数据库的连接，它可以申请连接,也可以修改连接。当用户连接到数据库时，SQL会话就被初始化了。 命令如下 1CONNECT user@database DISCONNECT/NEXT命令DISCONNECT用于断开用户与数据库的连接。当用户连接到数据库时，SQL会话就被结束了。 当使用EXIT命令离开数据库时，SQL会话就结束了，而且用于访问数据库的软件通常会关闭。 SQL命令的类型DDL—数据库定义语言DDL用于创建和重构数据库对象。 基本的DDL命令： 12345678CREATE TABLEALTER TABLEDROP TABLECREATE INDEXALTER INDEXDROP INDEXCREATE VIEWDROP VIEW DML—数据库操作语言DML用于操作关系型数据库对象内部的数据。 基本命令： 123INSERTUPDATEDELETE DQL—数据查询语句基本命令SELECT DCL—数据控制语言DCL用于控制对数据库里数据的访问，通常用于创建与用户访问相关的对象，以及控制用户权限。 基本命令： 1234ALTER PASSWORDGRANTREVOKECREATE SYNONYM 数据管理命令用于对数据库里的操作进行审计和分析，还有助于分析系统性能。 基本命令： 12START AUDITSTOP AUDIT 事务控制命令用于管理数据库事务 1234COMMIT //保存数据库事务ROLLBACK //撤销数据库事务SAVEPIONT //在一组事务里创建标记点以用于回退（ROLLBACK）SET TRANSACTION //设置实物名称]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL管理数据库对象]]></title>
    <url>%2Fposts%2F2709286209%2F</url>
    <content type="text"><![CDATA[数据库对象数据库里定义的、用于存储或是引用数据的对象，比如表、视图、簇、序列、索引和异名。 创建表CREATE TABLE 命令 使用方法： 123456CREATE TABLE &lt;表名&gt;( &lt;列名&gt; &lt;数据类型&gt; [列级完整新约束], //列级完整新约束 eg：primary key &lt;列名&gt; &lt;数据类型&gt; [列级完整新约束], ... [,&lt;表级完整性约束&gt;]); Eg: 12345678910CREATE TABLE EMPLOYEE_TBL( EMP_ID CHAR(9) NOT NULL, EMP_NAME VARCHAR(40) NOT NULL, EMP_ST_ADDR VARCHAR(20) NOT NULL, EMP_CITY VARCHAR(15) NOT NULL, EMP_ST CHAR(2) NOT NULL, EMP_ZIP INTEGER NOT NULL, EMP_PHONE INTEGER NULL, EMP_PAGER INTEGER NULL); 修改表ALTER TABLE 命令 修改表的列的属性列的属性：数据类型、长度、有效位或标度、是否为空 123456ALTER TABLE &lt;表名&gt;ADD [COLUMN] &lt;新列名&gt;&lt;数据类型&gt;[完整新约束]ADD &lt;表级完整新约束&gt;DROP [COLUMN] &lt;列名&gt; [CASCADE|RESTRICT]DROP CONSTRAINT&lt;完整性约束名&gt; [RESTRICT|CASCADE]ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt; CASCADE：自动删除引用了该类的其他对象，如视图 RESTRICT：如果该列被其他对象引用，RDBMS拒绝删除该列 Eg： 123456789101112//把EMP_ID的数据类型长度从9改为10.ALTER TABLE EMPLOYEE_TBL ALTER COLUMN EMP_ID VARCHAR(10);//新增EMP_ENGLISH_NAME列ALTER TABLE EMPLOYEE_TBLADD EMP_ENGLISH_NAME VARCHAR(20);//删除EMP_ENGLISH_NAME列ALTER TABLE EMPLOYEE_TBLDROP COLUMN EMP_ENGLISH_NAME; 添加自动增加的列使用IDENTITY类型 1234CREATE TABLE TEST_INCREMENT( ID INT IDENTITY(1,1) NOT NULL, //(seed = 1,increment = 1) 從1開始,每次遞增1 TEST_NAME VARCHAR(20)); ##删除表 1DROP TABLE &lt;表名&gt; [CASCADE|RESTRICT]; 完整性约束主键约束唯一性约束###外键约束]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL事务]]></title>
    <url>%2Fposts%2F2510228647%2F</url>
    <content type="text"><![CDATA[事务事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 控制事务###COMMIT命令 用于把事务所做的修改保存到数据库，把上一个COMMIT或ROLLBACK命令之后的全部事务都保存到数据库。 123begin transactionsql语句commit; ###ROLLBACK命令 用于撤销还没有被保存到数据库的命令，它只能用于撤销上一个COMMIT或ROLLBACK命令之后的实物。 123begin transactionsql语句rollback; eg: 1234567begin transaction update products_tblset cost = 8where prod_id = &apos;11235&apos;;rollback;//上面语句会撤销更新的sql，不会让&apos;11235&apos;的prod_id更新为8，而是原来的值 ###SAVEPOINT 保存点是事务过程中的一个逻辑点，我们可以把事务回退到这个点，而步兵回退到整个实物。 创建savepoint1save transaction savepoint_name 回退到savepoint1rollback transaction savepoint_name eg: 1234567891011121314151617181920BEGIN TRANSACTIONsave transaction sp1 //保存点1 更新&apos;11235&apos;的cost为80update products_tblset cost = 80where prod_id = &apos;11235&apos;;save transaction sp2 //保存点2 更新&apos;11235&apos;的cost为99update products_tblset cost = 99where prod_id = &apos;11235&apos;select * //查询 得到&apos;11235&apos;的cost为99from products_tbl; rollback transaction sp2; //回退到保存点2 得到&apos;11235&apos;的cost为80select * //查询 得到&apos;11235&apos;的cost为80from products_tbl;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常机制]]></title>
    <url>%2Fposts%2F2734622047%2F</url>
    <content type="text"><![CDATA[概述异常：程序在运行时出现不正常情况。 Java将异常分为checked异常、unchecked异常 unchecked异常(非受查异常)定义：所有派生于Error类或RuntimeException类的异常都称为unchecked异常 如果在函数内抛出异常，函数上不用声明，函数一样通过。 如果在函数上声明了该异常，调用者可以不用进行处理，编译一样通过。 之所以不用函数声明，是因为不需要让调用者处理。当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，由程序员修改。 Checked异常（受查异常）定义：不是RuntimeException类及其子类的实例都称为Checked异常。 可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException如果不处理，编译器，就不让你通过。 也就是说Java认为Checked异常是可以修复的异常，所以Java程序必须显式处理Checked异常，如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。 运行时异常与非运行时异常的区别：运行时异常是不可查异常，不需要进行显式的捕捉非运行时异常是可查异常，必须进行显示的捕捉，或者抛出 异常处理机制当程序运行出现意外情形时，系统会自动生成一个Exception对象来通知程序，从而实现将”业务功能实现代码“和“错误处理代码”分离，提供更好的可读性。 总结：一个方法必须声明所有可能抛出的(check)受查异常，而（uncheck）非受查异常要么不可控制（Error）要么就应该避免发生（RuntimeException）。 下面为异常的处理 方式一：try…catch捕获异常12345678910111213try&#123; //有可能产生异常的业务实现代码&#125;catch(Exception e)//异常对象&#123; System.out.println(e.toString());//异常名称：异常信息 e.printStackTrace();//异常名称：异常信息,异常出现的位置&#125;finally&#123; //一定会执行的语句&#125; 方式二：使用throws声明抛出异常使用场景：当前方法不知道如何处理这种类型或者是可能抛出的异常，该异常应该由上一级调用者处理；如果main方法也不知道如何处理这种类型的异常，就使用throws声明抛出异常。该异常交给JVM处理，JVM对异常的处理方法是，打印异常的跟踪栈信息，并终止程序运行。 123456789101112131415161718192021222324252627282930313233package exception;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;public class TestException &#123; public static void main(String[] args) &#123; method1(); &#125; private static void method1() &#123; try &#123; //因为method2()方法声明抛出FileNotFoundException异常，所以调用该方法的代码要么放在try块中显示捕获该异常，要么放在另一个带throws声明抛出的方法中。 method2(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //该方法希望它的调用者来处理异常,也就是说，调用该方法时要么放在try块中显示捕获该异常，要么放在另一个带throws声明抛出的方法中。 private static void method2() throws FileNotFoundException &#123; File f = new File("d:/LOL.exe"); System.out.println("试图打开 d:/LOL.exe"); new FileInputStream(f); System.out.println("成功打开"); &#125;&#125; 注意：throws声明抛出异常时有限制：子类方法声明抛出的异常类型应该是父类方法声明抛出类型的子类或相同，子类方法声明抛出异常不允许比父类方法声明抛出的异常多。如下 123456789101112131415public class OverrideThrows&#123; public void test() throws IOException &#123; FileInputStream fis = new FileInputStream("a.txt"); &#125;&#125;class Sub extends OverrideThrows&#123; // 子类方法声明抛出了比父类方法更大的异常 // 所以下面方法出错 public void test() throws Exception &#123; &#125;&#125; 抛出异常：代码出现异常时，系统自动生成一个异常对象，该异常对象被提交给Java环境。 捕获异常：Java运行时环境收到异常对象，会寻找能处理该异常对象的catch块，如果找到合适的catch块，则把该异常对象交给catch块处理。 程序自行抛出异常（throw）throw语句抛出的不是异常类，而是一个异常实例；语法如下： throw ExceptionInstance; 1234567try&#123; if(业务实现代码出现异常的条件)&#123; throw new Exception("出现异常")；&#125;&#125;catch(Exception e)&#123; System.out.println("异常");&#125; throws与throw区别throws使用在函数上；throw使用在函数内。 throws后面跟的异常类，可以跟多个，用逗号隔开；throw后面跟的是异常对象。 访问异常信息1234getMessage():返回该异常的详细描述字符串printStackTrace():将该异常的跟踪栈信息输出到标准错误输出printStackTrace(PrintStream s):将该异常的跟踪栈信息输出到指定输出流。getStackTrace():返回该异常的跟踪栈信息。 自定义异常应用场景:项目中会出现特有问题，而这些问题并未被java所所描述并封装对象。所以对于这些特有的问题可以按照java的对问题的封装思想，将特有的问题，进行自定义的异常封装。自定义异常必须继承Exception类。 创建自定义异常 一个英雄攻击另一个英雄的时候，如果发现另一个英雄已经挂了，就会抛出EnemyHeroIsDeadException创建一个类EnemyHeroIsDeadException，并继承Exception提供两个构造方法 无参的构造方法 带参的构造方法，并调用父类的对应的构造方法 123456789class EnemyHeroIsDeadException extends Exception&#123; public EnemyHeroIsDeadException()&#123; &#125; public EnemyHeroIsDeadException(String msg)&#123; super(msg); &#125;&#125; ​ 抛出自定义异常 在Hero的attack方法中，当发现敌方英雄的血量为0的时候，抛出该异常 创建一个EnemyHeroIsDeadException实例 通过throw 抛出该异常 当前方法通过 throws 抛出该异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Hero &#123; public String name; protected float hp; public void attackHero(Hero h) throws EnemyHeroIsDeadException&#123; if(h.hp == 0)&#123; throw new EnemyHeroIsDeadException(h.name + " 已经挂了,不许要施放技能" ); &#125; &#125; public String toString()&#123; return name; &#125; class EnemyHeroIsDeadException extends Exception&#123; public EnemyHeroIsDeadException()&#123; &#125; public EnemyHeroIsDeadException(String msg)&#123; super(msg); &#125; &#125; public static void main(String[] args) &#123; Hero garen = new Hero(); garen.name = "盖伦"; garen.hp = 616; Hero teemo = new Hero(); teemo.name = "提莫"; teemo.hp = 0; try &#123; garen.attackHero(teemo); &#125; catch (EnemyHeroIsDeadException e) &#123; // TODO Auto-generated catch block System.out.println("异常的具体原因:"+e.getMessage()); e.printStackTrace(); &#125; &#125;&#125; ​ finally作用：回收try块中打开了一些物理资源（例如数据库连接、网络连接和磁盘文件等），这些资源都必须显示回收。 不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally总会被执行。 Throwable Throwable是类，Exception和Error都继承了该类，所以在捕捉的时候，也可以使用Throwable进行捕捉。如图： 异常分Error和ExceptionException里又分运行时异常和可查异常。 123456789101112131415161718import java.io.File;import java.io.FileInputStream; public class TestException &#123; public static void main(String[] args) &#123; File f = new File("d:/LOL.exe"); try &#123; new FileInputStream(f); //使用Throwable进行异常捕捉 &#125; catch (Throwable t) &#123; // TODO Auto-generated catch block t.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解面向对象]]></title>
    <url>%2Fposts%2F2028349334%2F</url>
    <content type="text"><![CDATA[概述JAVA面向对象的三大特性：封装、继承、多态面向对象和面向过程都是一种思考方式。面向过程：打开冰箱/放东西进冰箱/关闭冰箱，强调动作过程。面向对象：冰箱.打开/冰箱.放东西/冰箱.关闭，强调冰箱这一对象。举例：向过程到面向对象是从执行者到指挥者餐厅点菜：我找服务员，服务员就是对象，服务员具有点菜功能。HR面试我：我就是对象，我就是对象，具备有HR需要的人的技能。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题]]></title>
    <url>%2Fposts%2F2817498189%2F</url>
    <content type="text"><![CDATA[Java面试题原文链接 Java基础1. 面向对象的理解面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 2. 自动装箱/拆箱机制如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以下面的面试题中f1== f2的结果是true，而f3== f4的结果是false。 1234567public class test &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); //true System.out.println(f3 == f4); //false &#125;&#125; 3.栈(stack)、堆(heap)和静态区(static area)栈：定义一个基本数据类型的变量，一个对象的引用，函数调用的现场保存；堆：通过new关键字和构造器创建的对象；堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；静态区：程序中的字面量（literal）如直接书写的100、”hello”和常量；都是放在常量池中，常量池是方法区的一部分 栈空间操作起来最快但是栈很小。通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。 1String str = new String("Hello"); 栈：str堆：用new创建出来的字符串对象静态区：&quot;hello&quot;这个字面量 4. Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。 5.抽象类（abstract class）和接口（interface）有什么异同？答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 6.String s = new String(“xyz”);创建了几个字符串对象？答：两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。 7.接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。 8.Java 中的final关键字有哪些用法？答： 修饰类：表示该类不能被继承； 修饰方法：表示方法不能被重写； 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。 9. == 和equal()和hashCode()==：判断对象地址是否相等，基本类型就直接判断其值是否相等，引用数据类型比较的是地址 equal()：重写，根据重写的方法比较，没有重写，比较的是内存地址 hashCode() : 集合元素是否重复的判断依据，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。 hashcode能大大降低对象比较次数，提高查找效率 Java对象的eqauls方法和hashCode方法是这样规定的： 1、相等**（相同）**的对象必须具有相等的哈希码（或者散列码）。 2、如果两个对象的hashCode相同，它们并不一定相同。 MyBatis1. #{}和${}的区别#{}预编译处理，MyBatis会把sql的中的#{}替换成？号，调用PreparedStatment的set方法来赋值，可以防止sql注入，提高安全性。 ${}字符串替换，MyBatis会把${}替换成对应变量的值。 Redis1. Redis是什么？高性能键值对（key-value）的内存数据库，可以作为数据库，缓存，消息中间件，是NoSQL（非关系型）的数据库。redis运行在内存中，但是可以持久化到磁盘里。 2. 五种数据类型String，Hash，List，Set，Sorted Set(zSet) 3. redis是单进程单线程的redis利用队列技术将并发访问变为串行访问 4. 一个字符串类型的值存储的最大容量？512M 5. redis的持久化机制RDB和AOF RDB：数据集快照的方式半持久化模式记录redis数据库的所有键值对，在一个时间掉将数据写入一个临时文件，持久化结束，用临时文件恢复数据。 dump.rdb, fork子线程完成写操作。 AOF: 把所有对redis的服务器进行修改的命令都存到一个 文件里，命令的集合。 6. redis过期删除策略]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2Fposts%2F2515320506%2F</url>
    <content type="text"><![CDATA[Tomcat Tomcat服务器是一种Servlet/JSP容器，负责处理客户请求，把请求传送给Servlet并把结果返回给客户。 当用户访问某个Servlet时，Servlet容器将创建一个ServletRequest对象和ServletResponse对象。在ServletRequest对象中封装了客户请求信息，然后Servlet容器（Tomcat）把ServletRequest对象和ServletResponse对象传给客户所请求的Servlet。Servlet把响应结果写到ServletResponse中，然后由Servlet容器（Tomcat）把响应结果传给客户。 修改端口安装目录为D:\Tomcat 打开D:\Tomcat\conf\server.xml，修改8080端口 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 运行多个服务如果需要让Tomcat运行多个服务，只需要复制server.xml文件中的元素，并修改相应的参数，便可以实现一个Tomcat运行多个服务。 Tomcat的结构每个Tomcat组件在server.xml文件中对应一种配置元素。以下为Tomcat组件之间的关系。 123456789101112&lt;Server&gt; //顶层类元素，可以包括多个Service &lt;Service&gt; //顶层类元素，可包含一个Engine，多个Connecter &lt;Connector&gt; //连接器类元素，代表通信接口 &lt;Engine&gt; //容器类元素，为特定的Service组件处理客户请求，要包含多个Host &lt;Host&gt; //容器类元素，为特定的虚拟主机组件处理客户请求，可包含多个Context &lt;Context&gt; //容器类元素，为特定的Web应用处理所有的客户请求 &lt;/Context&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Connector&gt; &lt;/Service&gt;&lt;/Server&gt; &lt;Server&gt;元素 &lt;Server&gt;元素代表整个Servlet容器，是Tomcat实例的顶层元素。&lt;Server&gt;元素中包含一个或多个&lt;Server&gt;元素。 &lt;Service&gt;元素 &lt;Service&gt;元素包含一个&lt;Engine&gt;元素，以及一个或多个&lt;Connector&gt;元素，这些&lt;Connector&gt;元素共享同一个&lt;Engine&gt;元素 &lt;Connector&gt;元素 &lt;Connector&gt;元素代表和客户程序实际交互的组件，它负责接收客户请求，以及向客户返回响应结果。 &lt;Engine&gt;元素 每个&lt;Service&gt;元素只能包含&lt;Engine&gt;元素。&lt;Engine&gt;元素处理在同一个&lt;Service&gt;中所有&lt;Connector&gt;元素接收到的客户请求。 &lt;Host&gt;元素 一个&lt;Engine&gt;元素可以包含多个&lt;Host&gt;元素。每个&lt;Host&gt;元素定义了一个虚拟主机，它可以包含一个或多个Web应用。 &lt;Context&gt;元素 &lt;Context&gt;元素是使用最频繁的元素，每个&lt;Context&gt;元素代表了运行在虚拟主机上的单个Web应用。一个&lt;Host&gt;元素中可以包含多个&lt;Context&gt;元素。 进入控制台Server Status控制台：监控服务器状态 Manager App控制台：部署、监控Web应用 Host Manager控制台 增加控制台用户打开D:\Tomcat\conf\tomcat-users.xml文件 在&lt;tomcat-users&gt;元素中增加用户 12345&lt;tomcat-users&gt; &lt;role rolename=&quot;tomcat&quot;/&gt; &lt;!--增加一个用户--&gt; &lt;user username=&apos;admin&apos; password = &apos;123456&apos; roles = &apos;manager-gui&apos;/&gt;&lt;/tomcat-users&gt; 部署Web应用方式一：利用Tomact的自动部署只要将一个Web应用复制到Tomcat的webapps下，系统就会把应用部署到Tomcat中。 方式二：利用控制台部署进入控制台，按照下图输入即可 ！ 将会在Tomcat的webapps目录多了一个名为tmall_ssh的文件夹，文件内容和D:\JAVA\workspace\路径tmall_ssh文件夹内容一样 Tomcat各个组件之间的嵌套关系 Tomcat Server处理一个HTTP请求的过程![img_Tomcat Server处理一个HTTP请求的过程](/images/img-Tomcat Server处理一个HTTP请求的过程.png) 用户点击网页内容，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得。 Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应。 Engine获得请求localhost/index.jsp，匹配所有的虚拟主机Host。 Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/index.jsp，匹配它所拥有的所有的Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）。 path=“/”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL PATTERN为*.jsp的Servlet,对应于JspServlet类。 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet（）或doPost（）.执行业务逻辑、数据存储等程序。 Context把执行完之后的HttpServletResponse对象返回给Host。 Host把HttpServletResponse对象返回给Engine。 Engine把HttpServletResponse对象返回Connector。 Connector把HttpServletResponse对象返回给客户Browser。]]></content>
      <categories>
        <category>Java_Web</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运行机制/JVM/JRE/JDK]]></title>
    <url>%2Fposts%2F2893851501%2F</url>
    <content type="text"><![CDATA[JAVA运行机制Java语言编写的程序需要经过编译步骤，这个编译步骤并不会生成特定平台的机器骂，而是生成一种与平台无关的字节码（也就是*.class文件），这种字节码不是可执行性的，必须使用Java解释器来解释执行。Java程序的执行过程需要想编译、后解释，如下： java源文件*.java—使用javac编译—&gt;编译生成*.class文件（字节码文件）—使用java解释执行—&gt;特定平台的机器码。 JVMJava语言里负责解释执行字节码文件的Java虚拟机，即JVM(Java Virtual Machine)。 问：为什么Java可以跨平台？ 答：当使用Java编译器编译Java程序时，生成的是与平台无关的字节码，这些字节码不面向任何具体平台，只面向JVM。不同平台上的JVM都是不同的，但是它们提供了相同的接口。只要不同平台实现了相应的虚拟机，编译后的Java字节码就可以在该平台上运行。 JREJRE（Java Runtime Environment，Java运行环境），包括Java虚拟机JVM和Java程序所需要的核心库等，如果要运行一个开发好的Java程序，计算机中只需要安装JRE。 JDKJDK（Java Development Kit，Java开发工具包），提供给Java开发人员使用的，其中包含了Java的开发工具（javac.exe 编译工具/jar.exe 打包工具），也包含了JRE。所以，安装了JDK后，不需要再单独安装JRE。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
