{"meta":{"title":"Number 47","subtitle":"Keep calm and carry on","description":"Keep calm and carry on","author":"Number 47","url":"https://number-47.github.io","root":"/"},"pages":[{"title":"","date":"2019-06-25T17:51:27.302Z","updated":"2019-05-25T05:38:39.530Z","comments":true,"path":"404.html","permalink":"https://number-47.github.io/404.html","excerpt":"","text":"404 - arao'blog"},{"title":"","date":"2019-06-25T17:51:27.302Z","updated":"2019-05-25T05:38:39.589Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"https://number-47.github.io/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"},{"title":"关于我","date":"2017-12-10T16:21:02.000Z","updated":"2019-05-25T05:38:39.587Z","comments":true,"path":"about/index.html","permalink":"https://number-47.github.io/about/index.html","excerpt":"","text":"hi，我是刘培涛，95年，喜欢画画，编程。 联系我邮箱：820368938@qq.com 微博：@Number-47 教育经历 学校 学历 专业 起至时间 北京师范大学珠海分校 本科 电子信息科学与技术 2014.9.1~2018.7.1 个人箴言KEEP CALM AND CARRY ON."},{"title":"分类","date":"2017-12-10T16:21:02.000Z","updated":"2019-05-25T05:38:39.588Z","comments":true,"path":"categories/index.html","permalink":"https://number-47.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2019-05-06T16:21:02.000Z","updated":"2019-05-25T05:38:39.613Z","comments":true,"path":"search/index.html","permalink":"https://number-47.github.io/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-12-10T16:20:43.000Z","updated":"2019-05-25T05:38:39.614Z","comments":true,"path":"tags/index.html","permalink":"https://number-47.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"spring security 学习(二)-自定义登录页登录与退出","slug":"Spring Security(二)-自定义登录页登录与退出","date":"2019-10-24T04:56:35.000Z","updated":"2019-10-13T18:07:30.731Z","comments":true,"path":"2019/10/24/Spring Security(二)-自定义登录页登录与退出/","link":"","permalink":"https://number-47.github.io/2019/10/24/Spring Security(二)-自定义登录页登录与退出/","excerpt":"","text":"Spring Security(二)-自定义登录页登录与退出","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://number-47.github.io/categories/Spring-Security/"}],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://number-47.github.io/tags/Spring-Security/"}]},{"title":"spring security","slug":"Spring Security","date":"2019-10-24T04:56:35.000Z","updated":"2019-10-13T16:58:11.599Z","comments":true,"path":"2019/10/24/Spring Security/","link":"","permalink":"https://number-47.github.io/2019/10/24/Spring Security/","excerpt":"","text":"Spring Security核心功能 认证（你是谁） 授权（你能干什么） 攻击防护（防止伪造身份） 基本原理 用户名+密码手机号+短信认证","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://number-47.github.io/categories/Spring-Security/"}],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://number-47.github.io/tags/Spring-Security/"}]},{"title":"spring security 学习(一)-spring boot 整合","slug":"spring security学习（一）-spring boot 整合","date":"2019-10-24T04:56:35.000Z","updated":"2019-10-13T17:14:19.504Z","comments":true,"path":"2019/10/24/spring security学习（一）-spring boot 整合/","link":"","permalink":"https://number-47.github.io/2019/10/24/spring security学习（一）-spring boot 整合/","excerpt":"","text":"Spring Security(一)-Spring Boot 整合创建spring boot项目，引入spring-boot-start-security1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 创建/spring-security的访问接口1234567@RestControllerpublic class DemoController &#123; @GetMapping(\"spring-security\") public String hello() &#123; return \"hello spring security\"; &#125;&#125; 表单认证创建配置类WebSecurityConfig继承WebSecurityConfigurerAdapter,WebSecurityConfigurerAdapter是由Spring Security提供的Web应用安全配置的适配器。 1234567891011121314@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单方式 .and() .authorizeRequests() .anyRequest() // 所有请求 .authenticated(); // 都需要认证 &#125;&#125; 设置启动端口application.properties 1server.port=8081 启动程序，启动时控制台Using generated security password: 9aac6105-0752-4bf1-9f54-c247e94086ab，每次都不一样，这个为用户user的密码。访问http://localhost:8080/spring-security，页面跳转到http://localhost:8080/login登录后，访问到http://localhost:8080/spring-security","categories":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://number-47.github.io/categories/Spring-Security/"}],"tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://number-47.github.io/tags/Spring-Security/"}]},{"title":"Rest API的拦截","slug":"Rest API的拦截","date":"2019-08-18T15:58:17.411Z","updated":"2019-10-13T17:02:34.719Z","comments":true,"path":"2019/08/18/Rest API的拦截/","link":"","permalink":"https://number-47.github.io/2019/08/18/Rest API的拦截/","excerpt":"","text":"Rest API的拦截拦截顺序filter-&gt;Interceptor-&gt;Aspect 异常捕获顺序Aspect-&gt;ControllerAdvice-&gt;Inteceptor-&gt;filter 过滤器（Filter）可以获取到原始http请求和响应的信息，但是取不到处理方法的信息 自定义Filter spring boot添加@Component1234567891011121314151617181920212223242526272829303132333435package com.number47.com.number47.filter;import org.springframework.stereotype.Component;import javax.servlet.*;import java.io.IOException;import java.util.Date;/** * @author number47 * @date 2019/8/18 23:44 * @description Rest API filter */@Componentpublic class TimeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(\"time filter init\"); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"time filter start\"); long start = new Date().getTime(); filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"time filter：\" + (new Date().getTime()-start)); System.out.println(\"time filter finish\"); &#125; @Override public void destroy() &#123; System.out.println(\"time filter destroy\"); &#125;&#125; 加入第三方Filter spring boot12345678910111213141516171819202122232425262728package com.number47.com.number47.config;import com.number47.com.number47.filter.TimeFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import java.util.ArrayList;import java.util.List;/** * @author number47 * @date 2019/8/18 23:53 * @description */@Configurationpublic class WebConfig &#123; @Bean public FilterRegistrationBean timeFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); TimeFilter timeFilter = new TimeFilter(); registrationBean.setFilter(timeFilter); List&lt;String&gt; urls = new ArrayList&lt;&gt;(); urls.add(&quot;/*&quot;); registrationBean.setUrlPatterns(urls); return registrationBean; &#125;&#125; 拦截器(Interceptor)可以获取到原始http请求和响应的信息，可以获取处理方法的信息，但是获取不到参数的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.number47.com.number47.interceptor;import org.springframework.stereotype.Component;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Date;/** * @author number47 * @date 2019/8/19 00:01 * @description */@Componentpublic class TimeInterceptor implements HandlerInterceptor &#123; /** * controller 之前调用 * @param httpServletRequest * @param httpServletResponse * @param handle * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handle) throws Exception &#123; System.out.println(\"preHandle\"); System.out.println(((HandlerMethod)handle).getBean().getClass().getName()); System.out.println(((HandlerMethod)handle).getMethod().getName()); httpServletRequest.setAttribute(\"startTime\",new Date().getTime()); return true; &#125; /** * controller 方法处理之后调用，如果controller抛出异常，这个方法不会调用 * @param httpServletRequest * @param httpServletResponse * @param o * @param modelAndView * @throws Exception */ @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"postHandle\"); Long start = (Long)httpServletRequest.getAttribute(\"startTime\"); System.out.println(\"time interceptor 耗时：\" + (new Date().getTime() - start)); &#125; /** * controller 无论是正常还是抛出异常都会调用 * @param httpServletRequest * @param httpServletResponse * @param o * @param e * @throws Exception */ @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; System.out.println(\"afterCompletion\"); Long start = (Long)httpServletRequest.getAttribute(\"startTime\"); System.out.println(\"time interceptor 耗时：\" + (new Date().getTime() - start)); System.out.println(\"exception is \" + e); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.number47.com.number47.config;import com.number47.com.number47.filter.TimeFilter;import com.number47.com.number47.interceptor.TimeInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import java.util.ArrayList;import java.util.List;/** * @author number47 * @date 2019/8/18 23:53 * @description */@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired private TimeInterceptor timeInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(timeInterceptor); &#125;&#125; 切片(Aspect)获取不到原始http请求和响应的信息，可以获取参数的值 Spring Aop简介 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.number47.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Date;/** * @author number47 * @date 2019/8/19 00:29 * @description */@Aspect@Componentpublic class TimeAspect &#123; @Before(value = &quot;execution(* com.number47.web.controller.UserController.*(..))&quot;) public void before()&#123; System.out.println(&quot;方法调用之前&quot;); &#125; @After(value = &quot;execution(* com.number47.web.controller.UserController.*(..))&quot;) public void after()&#123; System.out.println(&quot;方法调用之后&quot;); &#125; @AfterThrowing(value = &quot;execution(* com.number47.web.controller.UserController.*(..))&quot;) public void afterThrowing()&#123; System.out.println(&quot;方法异常调用之后&quot;); &#125; @Around(value = &quot;execution(* com.number47.web.controller.UserController.*(..))&quot;) public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;time aspect start&quot;); long start = new Date().getTime(); Object object = proceedingJoinPoint.proceed(); Object[] args = proceedingJoinPoint.getArgs(); for (Object arg: args)&#123; System.out.println(&quot;arg is &quot; + arg); &#125; System.out.println(&quot;time aspect：&quot; + (new Date().getTime()-start)); System.out.println(&quot;包含上面所有情况&quot;); System.out.println(&quot;time aspect end&quot;); return object; &#125;&#125;","categories":[],"tags":[{"name":"Rest","slug":"Rest","permalink":"https://number-47.github.io/tags/Rest/"}]},{"title":"Hibernate Validator","slug":"Hibernate Validator","date":"2019-08-03T14:39:59.614Z","updated":"2019-10-13T17:01:07.715Z","comments":true,"path":"2019/08/03/Hibernate Validator/","link":"","permalink":"https://number-47.github.io/2019/08/03/Hibernate Validator/","excerpt":"","text":"Hibernate Validator 注解 作用 @Null 值必须为空 @Pattern(regex=) 字符串必须匹配正则表达式 @Size(min=,max=) 集合的元素数量必须在min和max之间 @CreditCardNumber(ignoreNonDigitCharacters) 字符串必须是信用卡号（按美国的标准验证的） @Email 字符串必须是Email地址 @Length(min=,max=) 检查字符串的长度 @NotBlank 字符串必须有字符 @NotEmpty 字符串不为null,集合有元素 @Range(min=,max=) 数字必须大于等于min,小于等于max @SafeHtml 字符串是安全的html @URL 字符串是合法的URL @NotNull 值不能为空 @AssertFalse 值必须为false @AssertTrue 值必须为true @DecimalMax(value=,inclusive=) 值必须小于等于（inclusive=true）/小于（inclusive=false）value属指定的值，可以注解在字符串类型的属性上 @DecimalMin(value=,inclusive=) 值必须大于等于（inclusive=true）/大于（inclusive=false）value属指定的值，可以注解在字符串类型的属性上 @Digits(integer=,fraction=) 数字格式检查。integer指定整数部分的最大长度，fraction指定小数部分的最大长度 @Future 值必须是未来的日期 @Past 值必须是过去的日期 @Max(value=) 值必须小于等于value指定的值。不能注解在字符串类型的属性上。 @Min(value=) 值必须大于等于value指定的值。不能注解在字符串类型的属性上。 通过@Valid,BindingResult使用校验/@JsonView指定属性的显示Public class User{ 123public interface UserSimpleView&#123;&#125;;public interface UserDetailView extends UserSimpleView&#123;&#125;; 123456789101112131415161718192021222324 /** * @NotBlank校验不为空 */@NotBlankprivate String password;private String userName;@JsonView(UserSimpleView.class)public String getUserName() &#123; return userName;&#125;public void setUserName(String userName) &#123; this.userName = userName;&#125;@JsonView(UserDetailView.class)public String getPassword() &#123; return password;&#125;public void setPassword(String password) &#123; this.password = password;&#125; } 123456789101112131415161718192021222324252627282930313233@RestController@RequestMapping(\"/user\")public class UserController &#123; @PostMapping @JsonView(User.UserSimpleView.class) //显示名称 public User userCreate(@Valid @RequestBody User user, BindingResult errors)&#123; //捕获没有通过校验的错误 if (errors.hasErrors())&#123; errors.getAllErrors().stream().forEach(error -&gt; System.out.println(error.getDefaultMessage())); &#125; System.out.println(user.getId()); System.out.println(user.getUserName()); System.out.println(user.getPassword()); System.out.println(user.getBirthDay()); user.setId(\"1\"); return user; &#125; /** * * @param userId 通过正则表达式 只能接受数字 * @return */ @GetMapping(\"/&#123;id:\\\\d+&#125;\") @JsonView(User.UserDetailView.class) //显示名称和密码 public User getInfo(@PathVariable(name = \"id\") String userId)&#123; User user = new User(); user.setUserName(\"JOJO\"); return user; &#125;&#125;","categories":[{"name":"Hibernate Validator","slug":"Hibernate-Validator","permalink":"https://number-47.github.io/categories/Hibernate-Validator/"}],"tags":[{"name":"Hibernate Validator","slug":"Hibernate-Validator","permalink":"https://number-47.github.io/tags/Hibernate-Validator/"}]},{"title":"导入import com.sun.rowset.CachedRowSetImpl，报错","slug":"导入CachedRowSetlmpl报错","date":"2018-01-10T04:56:00.000Z","updated":"2019-07-08T18:36:48.232Z","comments":true,"path":"2018/01/10/导入CachedRowSetlmpl报错/","link":"","permalink":"https://number-47.github.io/2018/01/10/导入CachedRowSetlmpl报错/","excerpt":"","text":"报错内容Access restriction: The type CachedRowSetImpl is not accessible due to restriction on required library C:\\glassfish3\\jdk7\\jre\\lib\\rt.jar 解决方法项目右键project build path中先移除JRE System Library，再添加库JRE System Library，之后就可以了。","categories":[{"name":"Java","slug":"Java","permalink":"https://number-47.github.io/categories/Java/"}],"tags":[{"name":"JAVA Web问题","slug":"JAVA-Web问题","permalink":"https://number-47.github.io/tags/JAVA-Web问题/"}]},{"title":"Servlet","slug":"Servlet","date":"2018-01-06T16:00:00.000Z","updated":"2019-05-25T05:38:39.579Z","comments":true,"path":"2018/01/07/Servlet/","link":"","permalink":"https://number-47.github.io/2018/01/07/Servlet/","excerpt":"","text":"doGet()当浏览器使用get方式提交数据的时候，servlet需要提供doGet()方法。哪些是get方式呢？ form默认的提交方式 如果通过一个超链访问某个地址 如果在地址栏直接输入某个地址 ajax指定使用get方式的时候doPost()当浏览器使用post方式提交数据的时候，servlet需要提供doPost()方法 哪些是post方式呢？ 在form上显示设置 method=”post”的时候 ajax指定post方式的时候service()在执行doGet()或者doPost()之前，都会先执行service()。由service()方法进行判断，到底该调用doGet()还是doPost()。可以发现，service(), doGet(), doPost() 三种方式的参数列表都是一样的。所以，有时候也会直接重写service()方法，在其中提供相应的服务，就不用区分到底是get还是post了。 生命周期一个Servlet的生命周期由 实例化，初始化，提供服务，销毁，被回收几个步骤组成。 requestrequest对象的类是HttpServletRequest，提供了很多有实用价值的方法。 request常见方法request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名” +request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr(): 浏览器所处于的客户机的IP地址request.getRemoteHost(): 浏览器所处于的客户机的主机名request.getRemotePort(): 浏览器所处于的客户机使用的网络端口request.getLocalAddr(): 服务器的IP地址request.getLocalName(): 服务器的主机名request.getMethod(): 得到客户机请求方式一般是GET或者POST。 获取参数request.getParameter(): 是常见的方法，用于获取单值的参数request.getParameterValues(): 用于获取具有多值得参数，比如注册的时候提交的爱好，可以使多选的。request.getParameterMap(): 用于遍历所有的参数，并返回Map类型。 获取头信息request.getHeader() 获取浏览器传递过来的头信息。比如getHeader(“user-agent”) 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息。 responseresponse是HttpServletResponse的实例，用于提供给浏览器的响应信息。 设置响应内容response.getWriter() 通过response.getWriter(); 获取一个PrintWriter 对象。可以使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。","categories":[{"name":"Java_Web","slug":"Java-Web","permalink":"https://number-47.github.io/categories/Java-Web/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://number-47.github.io/tags/Servlet/"}]},{"title":"IO流","slug":"理解IO流","date":"2018-01-02T04:56:00.000Z","updated":"2019-05-25T05:38:39.584Z","comments":true,"path":"2018/01/02/理解IO流/","link":"","permalink":"https://number-47.github.io/2018/01/02/理解IO流/","excerpt":"流的分类按流的流向输入流：只能从中读取数据，而不能向其写入数据。 输出流：只能从中写入数据，而不能向其读取数据。 按操作数据分类字符流：数据单元16位的字符。Reader和Writer作为基类。 字节流：数据单元8位的字节。InputStream和OutputStream作为基类。","text":"流的分类按流的流向输入流：只能从中读取数据，而不能向其写入数据。 输出流：只能从中写入数据，而不能向其读取数据。 按操作数据分类字符流：数据单元16位的字符。Reader和Writer作为基类。 字节流：数据单元8位的字节。InputStream和OutputStream作为基类。","categories":[{"name":"Java","slug":"Java","permalink":"https://number-47.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://number-47.github.io/tags/Java基础/"}]},{"title":"IO流——File类","slug":"IO—File类","date":"2018-01-01T04:56:00.000Z","updated":"2019-05-25T05:38:39.533Z","comments":true,"path":"2018/01/01/IO—File类/","link":"","permalink":"https://number-47.github.io/2018/01/01/IO—File类/","excerpt":"File类创建文件对象注：只是创建File对象，以下程序并不会在文件系统中创建这些目录或文件。 123456789101112131415package io;import java.io.File;public class CreateFile &#123; public static void main(String[] args) &#123; // 绝对路径 File f1 = new File(&quot;d:/TestFolder&quot;); System.out.println(&quot;f1的绝对路径：&quot; + f1.getAbsolutePath()); // 相对路径,相对于工作目录，如果在eclipse中，就是项目目录 File f2 = new File(&quot;text.exe&quot;); System.out.println(&quot;f2的绝对路径：&quot; + f2.getAbsolutePath()); // 把f1作为父目录创建文件对象 File f3 = new File(f1, &quot;text.exe&quot;); System.out.println(&quot;f3的绝对路径：&quot; + f3.getAbsolutePath()); &#125;&#125;","text":"File类创建文件对象注：只是创建File对象，以下程序并不会在文件系统中创建这些目录或文件。 123456789101112131415package io;import java.io.File;public class CreateFile &#123; public static void main(String[] args) &#123; // 绝对路径 File f1 = new File(&quot;d:/TestFolder&quot;); System.out.println(&quot;f1的绝对路径：&quot; + f1.getAbsolutePath()); // 相对路径,相对于工作目录，如果在eclipse中，就是项目目录 File f2 = new File(&quot;text.exe&quot;); System.out.println(&quot;f2的绝对路径：&quot; + f2.getAbsolutePath()); // 把f1作为父目录创建文件对象 File f3 = new File(f1, &quot;text.exe&quot;); System.out.println(&quot;f3的绝对路径：&quot; + f3.getAbsolutePath()); &#125;&#125; 运行结果如下： 常用方法访问文件名相关的方法 String getName()：返回此File对象所表示的文件名或路径名（如果是路径，则返回最后一级子路径名）。 String getPath()：返回此File对象所对应的路径名。 File getAbsoluteFile()：返回此File对象的绝对路径。 String getAbsolutePath()：返回此File对象所对应的绝对路径名。 String getParent()：返回此File对象所对应目录（最后一级子目录）的父目录名。 boolean ranameTo(File newName)：重命名此File对象所对应的文件或目录。 文件检测相关的方法 boolean exists()：判断File对象所对应的文件或目录是否存在。 boolean canWrite()：判断File对象所对应的文件或目录是否可写。 boolean canRead()：判断File对象所对应的文件或目录是否可读。 boolean isFile()：判断File对象所对应的是文件，而不是目录。 boolean isDirectory()：判断File对象所对应的是否是目录，而不是文件。 获取常规文件信息 long lastModified()：返回文件的最后修改时间。 long length()：返回文件内容的长度。 boolean setLastModified(long time)：设置文件或目录的最后修改时间。 文件操作相关的方法 boolean creatNewFile()：当此FIle对象所对应的文件不存在时，该方法将新建一个该File对象所指定的新文件。 boolean delete()：删除File对象所对应的文件或路径。 ##目录操作相关的方法 boolean mkdir()：创建一个File对象所对应的目录。 boolean mkdirs()：创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。 String[] list()：列出File对象的所有子文件名和路径名，返回String数组。 File[] listFiles()：列出File对象的所有子文件名和路径名，返回File数组。 static File[] listRoot()：列出系统所有根路径。","categories":[{"name":"Java","slug":"Java","permalink":"https://number-47.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://number-47.github.io/tags/Java基础/"}]},{"title":"SQL事务","slug":"SQL事务","date":"2017-12-10T04:56:35.000Z","updated":"2019-05-25T05:38:39.536Z","comments":true,"path":"2017/12/10/SQL事务/","link":"","permalink":"https://number-47.github.io/2017/12/10/SQL事务/","excerpt":"事务事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 控制事务###COMMIT命令 用于把事务所做的修改保存到数据库，把上一个COMMIT或ROLLBACK命令之后的全部事务都保存到数据库。 123begin transactionsql语句commit;","text":"事务事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 控制事务###COMMIT命令 用于把事务所做的修改保存到数据库，把上一个COMMIT或ROLLBACK命令之后的全部事务都保存到数据库。 123begin transactionsql语句commit; ###ROLLBACK命令 用于撤销还没有被保存到数据库的命令，它只能用于撤销上一个COMMIT或ROLLBACK命令之后的实物。 123begin transactionsql语句rollback; eg: 1234567begin transaction update products_tblset cost = 8where prod_id = &apos;11235&apos;;rollback;//上面语句会撤销更新的sql，不会让&apos;11235&apos;的prod_id更新为8，而是原来的值 ###SAVEPOINT 保存点是事务过程中的一个逻辑点，我们可以把事务回退到这个点，而步兵回退到整个实物。 创建savepoint1save transaction savepoint_name 回退到savepoint1rollback transaction savepoint_name eg: 1234567891011121314151617181920BEGIN TRANSACTIONsave transaction sp1 //保存点1 更新&apos;11235&apos;的cost为80update products_tblset cost = 80where prod_id = &apos;11235&apos;;save transaction sp2 //保存点2 更新&apos;11235&apos;的cost为99update products_tblset cost = 99where prod_id = &apos;11235&apos;select * //查询 得到&apos;11235&apos;的cost为99from products_tbl; rollback transaction sp2; //回退到保存点2 得到&apos;11235&apos;的cost为80select * //查询 得到&apos;11235&apos;的cost为80from products_tbl;","categories":[{"name":"SQL","slug":"SQL","permalink":"https://number-47.github.io/categories/SQL/"}],"tags":[{"name":"SQL入门经典","slug":"SQL入门经典","permalink":"https://number-47.github.io/tags/SQL入门经典/"}]},{"title":"SQL数据库查询","slug":"SQL数据库查询","date":"2017-12-10T04:56:35.000Z","updated":"2019-05-25T05:38:39.577Z","comments":true,"path":"2017/12/10/SQL数据库查询/","link":"","permalink":"https://number-47.github.io/2017/12/10/SQL数据库查询/","excerpt":"Select语句数据库查询语句(DQL) 1234select [* | distinct column1 , column2 ]from table [,table2]where [condition1 | expression1] [and | orcondition2 | expression2 ]order by column1 | integer [ASC升序 | DESC降序] distinct：在结果中去除重复的记录。order by：输出结果以某种形式排序。默认升序ascorder by可以使用整数代表字段","text":"Select语句数据库查询语句(DQL) 1234select [* | distinct column1 , column2 ]from table [,table2]where [condition1 | expression1] [and | orcondition2 | expression2 ]order by column1 | integer [ASC升序 | DESC降序] distinct：在结果中去除重复的记录。order by：输出结果以某种形式排序。默认升序ascorder by可以使用整数代表字段eg: 123456789101112select *from products_tblorder by 1;//上面查询语句输出的会按照products_tbl的第一个字段进行升序排序。select *from products_tblorder by 1，2;//上面查询语句输出的会先对products_tbl的第一个字段进行升序排序，再对第二个字段进行升序排序。select *from products_tblorder by 1，2 desc;//上面查询语句输出的会先对products_tbl的第一个字段进行升序排序，再对第二个字段进行降序排序。 统计表里的记录数量COUNT()12345select COUNT(*)from table_name;//查询table_name的表中有多少行数据如果统计的字段规定not null，那么统计结果和表里的数量相同如果统计字段规定可以null，那么就只统计有数据的数据。 eg： 123select COUNT(PROD_ID)from PRODUCTS_TBL;//统计PRODUCTS_TBL里字段PROD_ID的值的数量 使用字段别名12select column_name alias_name(别名)from table_name eg: 12select prod_desc, prod_desc productfrom products_tbl;","categories":[{"name":"SQL","slug":"SQL","permalink":"https://number-47.github.io/categories/SQL/"}],"tags":[{"name":"SQL入门经典","slug":"SQL入门经典","permalink":"https://number-47.github.io/tags/SQL入门经典/"}]},{"title":"SQL基本概念","slug":"SQL基本概念","date":"2017-12-10T04:56:35.000Z","updated":"2019-05-25T05:38:39.537Z","comments":true,"path":"2017/12/10/SQL基本概念/","link":"","permalink":"https://number-47.github.io/2017/12/10/SQL基本概念/","excerpt":"概念DBMS（数据库管理系统）数据库管理系统，数据被保存在数据库中，这种机制叫做数据库管理系统。 RDBMS:关系型数据库管理系统。 DBA（数据库管理员）数据库管理员 DBS(数据库系统)由数据库、数据库管理系统（及其应用的开发工具）、应用数据和DBA组成的存储、管理、处理和维护数据的系统。 SQL结构化查询语句是与关系型数据库进行通信的标准语言。","text":"概念DBMS（数据库管理系统）数据库管理系统，数据被保存在数据库中，这种机制叫做数据库管理系统。 RDBMS:关系型数据库管理系统。 DBA（数据库管理员）数据库管理员 DBS(数据库系统)由数据库、数据库管理系统（及其应用的开发工具）、应用数据和DBA组成的存储、管理、处理和维护数据的系统。 SQL结构化查询语句是与关系型数据库进行通信的标准语言。 SQL会话用户利用SQL命令与关系型数据库进行交互时发生的事情。当用户与数据库建立连接时，会话就被建立了。会话可以通过直接与数据库建立链接来申请，也可以通过前端程序来申请。无论何种情况，会话通常是由通过网络访问数据库的用户在终端或工作站建立的。 CONNECT命令CONNECT用于建立与数据库的连接，它可以申请连接,也可以修改连接。当用户连接到数据库时，SQL会话就被初始化了。 命令如下 1CONNECT user@database DISCONNECT/NEXT命令DISCONNECT用于断开用户与数据库的连接。当用户连接到数据库时，SQL会话就被结束了。 当使用EXIT命令离开数据库时，SQL会话就结束了，而且用于访问数据库的软件通常会关闭。 SQL命令的类型DDL—数据库定义语言DDL用于创建和重构数据库对象。 基本的DDL命令： 12345678CREATE TABLEALTER TABLEDROP TABLECREATE INDEXALTER INDEXDROP INDEXCREATE VIEWDROP VIEW DML—数据库操作语言DML用于操作关系型数据库对象内部的数据。 基本命令： 123INSERTUPDATEDELETE DQL—数据查询语句基本命令SELECT DCL—数据控制语言DCL用于控制对数据库里数据的访问，通常用于创建与用户访问相关的对象，以及控制用户权限。 基本命令： 1234ALTER PASSWORDGRANTREVOKECREATE SYNONYM 数据管理命令用于对数据库里的操作进行审计和分析，还有助于分析系统性能。 基本命令： 12START AUDITSTOP AUDIT 事务控制命令用于管理数据库事务 1234COMMIT //保存数据库事务ROLLBACK //撤销数据库事务SAVEPIONT //在一组事务里创建标记点以用于回退（ROLLBACK）SET TRANSACTION //设置实物名称","categories":[{"name":"SQL","slug":"SQL","permalink":"https://number-47.github.io/categories/SQL/"}],"tags":[{"name":"SQL入门经典","slug":"SQL入门经典","permalink":"https://number-47.github.io/tags/SQL入门经典/"}]},{"title":"SQL管理数据库对象","slug":"SQL数据库对象","date":"2017-12-10T04:56:35.000Z","updated":"2019-05-25T05:38:39.576Z","comments":true,"path":"2017/12/10/SQL数据库对象/","link":"","permalink":"https://number-47.github.io/2017/12/10/SQL数据库对象/","excerpt":"数据库对象数据库里定义的、用于存储或是引用数据的对象，比如表、视图、簇、序列、索引和异名。 创建表CREATE TABLE 命令 使用方法： 123456CREATE TABLE &lt;表名&gt;( &lt;列名&gt; &lt;数据类型&gt; [列级完整新约束], //列级完整新约束 eg：primary key &lt;列名&gt; &lt;数据类型&gt; [列级完整新约束], ... [,&lt;表级完整性约束&gt;]); Eg:","text":"数据库对象数据库里定义的、用于存储或是引用数据的对象，比如表、视图、簇、序列、索引和异名。 创建表CREATE TABLE 命令 使用方法： 123456CREATE TABLE &lt;表名&gt;( &lt;列名&gt; &lt;数据类型&gt; [列级完整新约束], //列级完整新约束 eg：primary key &lt;列名&gt; &lt;数据类型&gt; [列级完整新约束], ... [,&lt;表级完整性约束&gt;]); Eg: 12345678910CREATE TABLE EMPLOYEE_TBL( EMP_ID CHAR(9) NOT NULL, EMP_NAME VARCHAR(40) NOT NULL, EMP_ST_ADDR VARCHAR(20) NOT NULL, EMP_CITY VARCHAR(15) NOT NULL, EMP_ST CHAR(2) NOT NULL, EMP_ZIP INTEGER NOT NULL, EMP_PHONE INTEGER NULL, EMP_PAGER INTEGER NULL); 修改表ALTER TABLE 命令 修改表的列的属性列的属性：数据类型、长度、有效位或标度、是否为空 123456ALTER TABLE &lt;表名&gt;ADD [COLUMN] &lt;新列名&gt;&lt;数据类型&gt;[完整新约束]ADD &lt;表级完整新约束&gt;DROP [COLUMN] &lt;列名&gt; [CASCADE|RESTRICT]DROP CONSTRAINT&lt;完整性约束名&gt; [RESTRICT|CASCADE]ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt; CASCADE：自动删除引用了该类的其他对象，如视图 RESTRICT：如果该列被其他对象引用，RDBMS拒绝删除该列 Eg： 123456789101112//把EMP_ID的数据类型长度从9改为10.ALTER TABLE EMPLOYEE_TBL ALTER COLUMN EMP_ID VARCHAR(10);//新增EMP_ENGLISH_NAME列ALTER TABLE EMPLOYEE_TBLADD EMP_ENGLISH_NAME VARCHAR(20);//删除EMP_ENGLISH_NAME列ALTER TABLE EMPLOYEE_TBLDROP COLUMN EMP_ENGLISH_NAME; 添加自动增加的列使用IDENTITY类型 1234CREATE TABLE TEST_INCREMENT( ID INT IDENTITY(1,1) NOT NULL, //(seed = 1,increment = 1) 從1開始,每次遞增1 TEST_NAME VARCHAR(20)); ##删除表 1DROP TABLE &lt;表名&gt; [CASCADE|RESTRICT]; 完整性约束主键约束唯一性约束###外键约束","categories":[{"name":"SQL","slug":"SQL","permalink":"https://number-47.github.io/categories/SQL/"}],"tags":[{"name":"SQL入门经典","slug":"SQL入门经典","permalink":"https://number-47.github.io/tags/SQL入门经典/"}]},{"title":"SQL数据类型","slug":"SQL数据类型","date":"2017-12-10T04:56:35.000Z","updated":"2019-05-25T05:38:39.578Z","comments":true,"path":"2017/12/10/SQL数据类型/","link":"","permalink":"https://number-47.github.io/2017/12/10/SQL数据类型/","excerpt":"SQL数据类型 CHAR(n)：定长数据类型 VARCHAR(n)：变长数据类型，n表示字段能够保存的最多字符数量 BLOB：大对象类型，二进制大对象，保存很长的二进制字符串 TEXT：长字符串类型，可以看作一个大VARCHAR字段","text":"SQL数据类型 CHAR(n)：定长数据类型 VARCHAR(n)：变长数据类型，n表示字段能够保存的最多字符数量 BLOB：大对象类型，二进制大对象，保存很长的二进制字符串 TEXT：长字符串类型，可以看作一个大VARCHAR字段 数值类型 BIT(n) BIT VARCHAR(n) DECIMAL(p, s) INTEGER SMALLINT BIGINT FLOAT(p, s) DOUBLE PRECISION(p, s) REAL(s)p表示字段的最大长度s表示小数点后面的位数 小数点类型DECIMAL(p, s) p：有效位数 s：标度 12eg:DECIMAL(4,2) 最大值为99.99//有效位数是4，也就是数值总位数是4，标度是2小数点后面的位数 如果实际数值的小数位数超出定义的位数，数字就会被四舍五入。 ##浮点数 REAL：单精度浮点数，单精度浮点数的有效位1—21（包含） DOUBLE PRECISION：双精度浮点数的有效位22—53（包含） 日期和时间类型 DATE TIME DATETIME TIMESTAMP ##直义字符串 一系列字符，比如姓名或电话号码，这是有用户或程序明确指定的。 自定义类型由用户定义的类型，允许用户根据已有的数据类型来定制自己的数据类型。 1234567891011MYSQL//创建自定义类型CRATE TYPE PERSON AS OBJECT(NAME VARCHAR(30),SSN VARCHAR(9));//引用自定义类型CREATE TABLE EMP_PAY(EMPLOYEE PERSON,SALARY DECIMAL(10,2),HIRE_DATE DATE); 域域是能够被使用的有效数据类型的集合。域与数据相关联，从而只接受待定的数据，在域创建之后，我们可以向域添加约束，约束与数据类型共同发挥作用，从而限制字段能够接受的数据。 123456789101112//创建域CREATE DOMAIN MONEY_D AS NUMBER(8,2);//添加约束ALTER DOMAIN MONEY_DADD CONSTRANINT MONEY_CON1CHECK (VALUE &gt; 5);//引用域CREATE TABLE EMP_PAY(EMP_ID NUMBER(9),EMP_NAME VARCHAR2(30),PAY_RATE MONET_D);","categories":[{"name":"SQL","slug":"SQL","permalink":"https://number-47.github.io/categories/SQL/"}],"tags":[{"name":"SQL入门经典","slug":"SQL入门经典","permalink":"https://number-47.github.io/tags/SQL入门经典/"}]},{"title":"理解面向对象","slug":"理解面向对象","date":"2017-12-07T04:56:00.000Z","updated":"2019-07-08T18:39:17.083Z","comments":true,"path":"2017/12/07/理解面向对象/","link":"","permalink":"https://number-47.github.io/2017/12/07/理解面向对象/","excerpt":"概述JAVA面向对象的三大特性：封装、继承、多态面向对象和面向过程都是一种思考方式。面向过程：打开冰箱/放东西进冰箱/关闭冰箱，强调动作过程。面向对象：冰箱.打开/冰箱.放东西/冰箱.关闭，强调冰箱这一对象。","text":"概述JAVA面向对象的三大特性：封装、继承、多态面向对象和面向过程都是一种思考方式。面向过程：打开冰箱/放东西进冰箱/关闭冰箱，强调动作过程。面向对象：冰箱.打开/冰箱.放东西/冰箱.关闭，强调冰箱这一对象。举例：向过程到面向对象是从执行者到指挥者餐厅点菜：我找服务员，服务员就是对象，服务员具有点菜功能。HR面试我：我就是对象，我就是对象，具备有HR需要的人的技能。","categories":[{"name":"Java","slug":"Java","permalink":"https://number-47.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://number-47.github.io/tags/Java基础/"}]},{"title":"异常机制","slug":"异常机制","date":"2017-12-07T04:56:00.000Z","updated":"2019-07-09T15:31:55.771Z","comments":true,"path":"2017/12/07/异常机制/","link":"","permalink":"https://number-47.github.io/2017/12/07/异常机制/","excerpt":"概述异常：程序在运行时出现不正常情况。 Java将异常分为checked异常、unchecked异常 unchecked异常(非受查异常)定义：所有派生于Error类或RuntimeException类的异常都称为unchecked异常 如果在函数内抛出异常，函数上不用声明，函数一样通过。 如果在函数上声明了该异常，调用者可以不用进行处理，编译一样通过。 之所以不用函数声明，是因为不需要让调用者处理。当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，由程序员修改。 Checked异常（受查异常）定义：不是RuntimeException类及其子类的实例都称为Checked异常。 可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException如果不处理，编译器，就不让你通过。 也就是说Java认为Checked异常是可以修复的异常，所以Java程序必须显式处理Checked异常，如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。 运行时异常与非运行时异常的区别：运行时异常是不可查异常，不需要进行显式的捕捉非运行时异常是可查异常，必须进行显示的捕捉，或者抛出","text":"概述异常：程序在运行时出现不正常情况。 Java将异常分为checked异常、unchecked异常 unchecked异常(非受查异常)定义：所有派生于Error类或RuntimeException类的异常都称为unchecked异常 如果在函数内抛出异常，函数上不用声明，函数一样通过。 如果在函数上声明了该异常，调用者可以不用进行处理，编译一样通过。 之所以不用函数声明，是因为不需要让调用者处理。当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，由程序员修改。 Checked异常（受查异常）定义：不是RuntimeException类及其子类的实例都称为Checked异常。 可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException如果不处理，编译器，就不让你通过。 也就是说Java认为Checked异常是可以修复的异常，所以Java程序必须显式处理Checked异常，如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。 运行时异常与非运行时异常的区别：运行时异常是不可查异常，不需要进行显式的捕捉非运行时异常是可查异常，必须进行显示的捕捉，或者抛出 异常处理机制当程序运行出现意外情形时，系统会自动生成一个Exception对象来通知程序，从而实现将”业务功能实现代码“和“错误处理代码”分离，提供更好的可读性。 总结：一个方法必须声明所有可能抛出的(check)受查异常，而（uncheck）非受查异常要么不可控制（Error）要么就应该避免发生（RuntimeException）。 下面为异常的处理 方式一：try…catch捕获异常12345678910111213try&#123; //有可能产生异常的业务实现代码&#125;catch(Exception e)//异常对象&#123; System.out.println(e.toString());//异常名称：异常信息 e.printStackTrace();//异常名称：异常信息,异常出现的位置&#125;finally&#123; //一定会执行的语句&#125; 方式二：使用throws声明抛出异常使用场景：当前方法不知道如何处理这种类型或者是可能抛出的异常，该异常应该由上一级调用者处理；如果main方法也不知道如何处理这种类型的异常，就使用throws声明抛出异常。该异常交给JVM处理，JVM对异常的处理方法是，打印异常的跟踪栈信息，并终止程序运行。 123456789101112131415161718192021222324252627282930313233package exception;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;public class TestException &#123; public static void main(String[] args) &#123; method1(); &#125; private static void method1() &#123; try &#123; //因为method2()方法声明抛出FileNotFoundException异常，所以调用该方法的代码要么放在try块中显示捕获该异常，要么放在另一个带throws声明抛出的方法中。 method2(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //该方法希望它的调用者来处理异常,也就是说，调用该方法时要么放在try块中显示捕获该异常，要么放在另一个带throws声明抛出的方法中。 private static void method2() throws FileNotFoundException &#123; File f = new File(\"d:/LOL.exe\"); System.out.println(\"试图打开 d:/LOL.exe\"); new FileInputStream(f); System.out.println(\"成功打开\"); &#125;&#125; 注意：throws声明抛出异常时有限制：子类方法声明抛出的异常类型应该是父类方法声明抛出类型的子类或相同，子类方法声明抛出异常不允许比父类方法声明抛出的异常多。如下 123456789101112131415public class OverrideThrows&#123; public void test() throws IOException &#123; FileInputStream fis = new FileInputStream(\"a.txt\"); &#125;&#125;class Sub extends OverrideThrows&#123; // 子类方法声明抛出了比父类方法更大的异常 // 所以下面方法出错 public void test() throws Exception &#123; &#125;&#125; 抛出异常：代码出现异常时，系统自动生成一个异常对象，该异常对象被提交给Java环境。 捕获异常：Java运行时环境收到异常对象，会寻找能处理该异常对象的catch块，如果找到合适的catch块，则把该异常对象交给catch块处理。 程序自行抛出异常（throw）throw语句抛出的不是异常类，而是一个异常实例；语法如下： throw ExceptionInstance; 1234567try&#123; if(业务实现代码出现异常的条件)&#123; throw new Exception(\"出现异常\")；&#125;&#125;catch(Exception e)&#123; System.out.println(\"异常\");&#125; throws与throw区别throws使用在函数上；throw使用在函数内。 throws后面跟的异常类，可以跟多个，用逗号隔开；throw后面跟的是异常对象。 访问异常信息1234getMessage():返回该异常的详细描述字符串printStackTrace():将该异常的跟踪栈信息输出到标准错误输出printStackTrace(PrintStream s):将该异常的跟踪栈信息输出到指定输出流。getStackTrace():返回该异常的跟踪栈信息。 自定义异常应用场景:项目中会出现特有问题，而这些问题并未被java所所描述并封装对象。所以对于这些特有的问题可以按照java的对问题的封装思想，将特有的问题，进行自定义的异常封装。自定义异常必须继承Exception类。 创建自定义异常 一个英雄攻击另一个英雄的时候，如果发现另一个英雄已经挂了，就会抛出EnemyHeroIsDeadException创建一个类EnemyHeroIsDeadException，并继承Exception提供两个构造方法 无参的构造方法 带参的构造方法，并调用父类的对应的构造方法 123456789class EnemyHeroIsDeadException extends Exception&#123; public EnemyHeroIsDeadException()&#123; &#125; public EnemyHeroIsDeadException(String msg)&#123; super(msg); &#125;&#125; ​ 抛出自定义异常 在Hero的attack方法中，当发现敌方英雄的血量为0的时候，抛出该异常 创建一个EnemyHeroIsDeadException实例 通过throw 抛出该异常 当前方法通过 throws 抛出该异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Hero &#123; public String name; protected float hp; public void attackHero(Hero h) throws EnemyHeroIsDeadException&#123; if(h.hp == 0)&#123; throw new EnemyHeroIsDeadException(h.name + \" 已经挂了,不许要施放技能\" ); &#125; &#125; public String toString()&#123; return name; &#125; class EnemyHeroIsDeadException extends Exception&#123; public EnemyHeroIsDeadException()&#123; &#125; public EnemyHeroIsDeadException(String msg)&#123; super(msg); &#125; &#125; public static void main(String[] args) &#123; Hero garen = new Hero(); garen.name = \"盖伦\"; garen.hp = 616; Hero teemo = new Hero(); teemo.name = \"提莫\"; teemo.hp = 0; try &#123; garen.attackHero(teemo); &#125; catch (EnemyHeroIsDeadException e) &#123; // TODO Auto-generated catch block System.out.println(\"异常的具体原因:\"+e.getMessage()); e.printStackTrace(); &#125; &#125;&#125; ​ finally作用：回收try块中打开了一些物理资源（例如数据库连接、网络连接和磁盘文件等），这些资源都必须显示回收。 不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally总会被执行。 Throwable Throwable是类，Exception和Error都继承了该类，所以在捕捉的时候，也可以使用Throwable进行捕捉。如图： 异常分Error和ExceptionException里又分运行时异常和可查异常。 123456789101112131415161718import java.io.File;import java.io.FileInputStream; public class TestException &#123; public static void main(String[] args) &#123; File f = new File(\"d:/LOL.exe\"); try &#123; new FileInputStream(f); //使用Throwable进行异常捕捉 &#125; catch (Throwable t) &#123; // TODO Auto-generated catch block t.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://number-47.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://number-47.github.io/tags/Java基础/"}]},{"title":"Tomcat","slug":"Tomcat","date":"2017-11-26T16:00:00.000Z","updated":"2019-05-25T05:38:39.581Z","comments":true,"path":"2017/11/27/Tomcat/","link":"","permalink":"https://number-47.github.io/2017/11/27/Tomcat/","excerpt":"Tomcat Tomcat服务器是一种Servlet/JSP容器，负责处理客户请求，把请求传送给Servlet并把结果返回给客户。 当用户访问某个Servlet时，Servlet容器将创建一个ServletRequest对象和ServletResponse对象。在ServletRequest对象中封装了客户请求信息，然后Servlet容器（Tomcat）把ServletRequest对象和ServletResponse对象传给客户所请求的Servlet。Servlet把响应结果写到ServletResponse中，然后由Servlet容器（Tomcat）把响应结果传给客户。","text":"Tomcat Tomcat服务器是一种Servlet/JSP容器，负责处理客户请求，把请求传送给Servlet并把结果返回给客户。 当用户访问某个Servlet时，Servlet容器将创建一个ServletRequest对象和ServletResponse对象。在ServletRequest对象中封装了客户请求信息，然后Servlet容器（Tomcat）把ServletRequest对象和ServletResponse对象传给客户所请求的Servlet。Servlet把响应结果写到ServletResponse中，然后由Servlet容器（Tomcat）把响应结果传给客户。 修改端口安装目录为D:\\Tomcat 打开D:\\Tomcat\\conf\\server.xml，修改8080端口 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 运行多个服务如果需要让Tomcat运行多个服务，只需要复制server.xml文件中的元素，并修改相应的参数，便可以实现一个Tomcat运行多个服务。 Tomcat的结构每个Tomcat组件在server.xml文件中对应一种配置元素。以下为Tomcat组件之间的关系。 123456789101112&lt;Server&gt; //顶层类元素，可以包括多个Service &lt;Service&gt; //顶层类元素，可包含一个Engine，多个Connecter &lt;Connector&gt; //连接器类元素，代表通信接口 &lt;Engine&gt; //容器类元素，为特定的Service组件处理客户请求，要包含多个Host &lt;Host&gt; //容器类元素，为特定的虚拟主机组件处理客户请求，可包含多个Context &lt;Context&gt; //容器类元素，为特定的Web应用处理所有的客户请求 &lt;/Context&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Connector&gt; &lt;/Service&gt;&lt;/Server&gt; &lt;Server&gt;元素 &lt;Server&gt;元素代表整个Servlet容器，是Tomcat实例的顶层元素。&lt;Server&gt;元素中包含一个或多个&lt;Server&gt;元素。 &lt;Service&gt;元素 &lt;Service&gt;元素包含一个&lt;Engine&gt;元素，以及一个或多个&lt;Connector&gt;元素，这些&lt;Connector&gt;元素共享同一个&lt;Engine&gt;元素 &lt;Connector&gt;元素 &lt;Connector&gt;元素代表和客户程序实际交互的组件，它负责接收客户请求，以及向客户返回响应结果。 &lt;Engine&gt;元素 每个&lt;Service&gt;元素只能包含&lt;Engine&gt;元素。&lt;Engine&gt;元素处理在同一个&lt;Service&gt;中所有&lt;Connector&gt;元素接收到的客户请求。 &lt;Host&gt;元素 一个&lt;Engine&gt;元素可以包含多个&lt;Host&gt;元素。每个&lt;Host&gt;元素定义了一个虚拟主机，它可以包含一个或多个Web应用。 &lt;Context&gt;元素 &lt;Context&gt;元素是使用最频繁的元素，每个&lt;Context&gt;元素代表了运行在虚拟主机上的单个Web应用。一个&lt;Host&gt;元素中可以包含多个&lt;Context&gt;元素。 进入控制台Server Status控制台：监控服务器状态 Manager App控制台：部署、监控Web应用 Host Manager控制台 增加控制台用户打开D:\\Tomcat\\conf\\tomcat-users.xml文件 在&lt;tomcat-users&gt;元素中增加用户 12345&lt;tomcat-users&gt; &lt;role rolename=&quot;tomcat&quot;/&gt; &lt;!--增加一个用户--&gt; &lt;user username=&apos;admin&apos; password = &apos;123456&apos; roles = &apos;manager-gui&apos;/&gt;&lt;/tomcat-users&gt; 部署Web应用方式一：利用Tomact的自动部署只要将一个Web应用复制到Tomcat的webapps下，系统就会把应用部署到Tomcat中。 方式二：利用控制台部署进入控制台，按照下图输入即可 ！ 将会在Tomcat的webapps目录多了一个名为tmall_ssh的文件夹，文件内容和D:\\JAVA\\workspace\\路径tmall_ssh文件夹内容一样 Tomcat各个组件之间的嵌套关系 Tomcat Server处理一个HTTP请求的过程![img_Tomcat Server处理一个HTTP请求的过程](/images/img-Tomcat Server处理一个HTTP请求的过程.png) 用户点击网页内容，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得。 Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应。 Engine获得请求localhost/index.jsp，匹配所有的虚拟主机Host。 Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/index.jsp，匹配它所拥有的所有的Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）。 path=“/”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL PATTERN为*.jsp的Servlet,对应于JspServlet类。 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet（）或doPost（）.执行业务逻辑、数据存储等程序。 Context把执行完之后的HttpServletResponse对象返回给Host。 Host把HttpServletResponse对象返回给Engine。 Engine把HttpServletResponse对象返回Connector。 Connector把HttpServletResponse对象返回给客户Browser。","categories":[{"name":"Java_Web","slug":"Java-Web","permalink":"https://number-47.github.io/categories/Java-Web/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://number-47.github.io/tags/Tomcat/"}]},{"title":"Java面试题","slug":"Java面试题","date":"2017-11-26T16:00:00.000Z","updated":"2019-05-25T05:38:39.535Z","comments":true,"path":"2017/11/27/Java面试题/","link":"","permalink":"https://number-47.github.io/2017/11/27/Java面试题/","excerpt":"Java面试题原文链接1.面向对象的理解面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。","text":"Java面试题原文链接1.面向对象的理解面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。2. 自动装箱/拆箱机制如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以下面的面试题中f1== f2的结果是true，而f3== f4的结果是false。 1234567public class test &#123; public static void main(String[] args) &#123; Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); //true System.out.println(f3 == f4); //false &#125;&#125; 3.栈(stack)、堆(heap)和静态区(static area)栈：定义一个基本数据类型的变量，一个对象的引用，函数调用的现场保存；堆：通过new关键字和构造器创建的对象；堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；静态区：程序中的字面量（literal）如直接书写的100、”hello”和常量；都是放在常量池中，常量池是方法区的一部分 栈空间操作起来最快但是栈很小。通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。 1String str = new String(\"Hello\"); 栈：str堆：用new创建出来的字符串对象静态区：&quot;hello&quot;这个字面量4. Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。*5.抽象类（abstract class）和接口（interface）有什么异同？ *答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。*6.String s = new String(“xyz”);创建了几个字符串对象？ *答：两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。*7.接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ *答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。*8.Java 中的final关键字有哪些用法？ *答： 修饰类：表示该类不能被继承； 修饰方法：表示方法不能被重写； 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。","categories":[{"name":"Java","slug":"Java","permalink":"https://number-47.github.io/categories/Java/"}],"tags":[{"name":"Java面试","slug":"Java面试","permalink":"https://number-47.github.io/tags/Java面试/"}]},{"title":"Java运行机制/JVM/JRE/JDK","slug":"Java运行机制和JVM","date":"2017-11-25T04:56:00.000Z","updated":"2019-07-08T18:35:49.815Z","comments":true,"path":"2017/11/25/Java运行机制和JVM/","link":"","permalink":"https://number-47.github.io/2017/11/25/Java运行机制和JVM/","excerpt":"JAVA运行机制Java语言编写的程序需要经过编译步骤，这个编译步骤并不会生成特定平台的机器骂，而是生成一种与平台无关的字节码（也就是*.class文件），这种字节码不是可执行性的，必须使用Java解释器来解释执行。Java程序的执行过程需要想编译、后解释，如下： java源文件*.java—使用javac编译—&gt;编译生成*.class文件（字节码文件）—使用java解释执行—&gt;特定平台的机器码。","text":"JAVA运行机制Java语言编写的程序需要经过编译步骤，这个编译步骤并不会生成特定平台的机器骂，而是生成一种与平台无关的字节码（也就是*.class文件），这种字节码不是可执行性的，必须使用Java解释器来解释执行。Java程序的执行过程需要想编译、后解释，如下： java源文件*.java—使用javac编译—&gt;编译生成*.class文件（字节码文件）—使用java解释执行—&gt;特定平台的机器码。 JVMJava语言里负责解释执行字节码文件的Java虚拟机，即JVM(Java Virtual Machine)。 问：为什么Java可以跨平台？ 答：当使用Java编译器编译Java程序时，生成的是与平台无关的字节码，这些字节码不面向任何具体平台，只面向JVM。不同平台上的JVM都是不同的，但是它们提供了相同的接口。只要不同平台实现了相应的虚拟机，编译后的Java字节码就可以在该平台上运行。 JREJRE（Java Runtime Environment，Java运行环境），包括Java虚拟机JVM和Java程序所需要的核心库等，如果要运行一个开发好的Java程序，计算机中只需要安装JRE。 JDKJDK（Java Development Kit，Java开发工具包），提供给Java开发人员使用的，其中包含了Java的开发工具（javac.exe 编译工具/jar.exe 打包工具），也包含了JRE。所以，安装了JDK后，不需要再单独安装JRE。","categories":[{"name":"Java","slug":"Java","permalink":"https://number-47.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://number-47.github.io/tags/Java基础/"}],"author":"number-47"}]}